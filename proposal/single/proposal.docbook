<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="tree" rev:last-revision="$Date: 2013/05/03 13:29:16 $">
  <title>Hierarchical Data Structures and Related Concepts for the C++ Standard Library</title>
  <articleinfo>
    <authorgroup>
    <author>
      <firstname>Bernhard</firstname> <surname>Reiter</surname>
    </author>
    <author>
      <firstname>René</firstname> <surname>Rivera</surname>
    </author>
    </authorgroup>
    <copyright>
      <year>2006</year> <year>2007</year> <year>2008</year> <year>2009</year> <holder>Bernhard
      Reiter</holder>
    </copyright>
    <copyright>
      <year>2006</year> <year>2007</year> <year>2008</year> <year>2009</year> <year>2010</year>
      <year>2011</year> <year>2012</year> <year>2013</year> <holder>René Rivera</holder>
    </copyright>
    <legalnotice id="tree.legal">
      <para>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
      </para>
    </legalnotice>
    <articlepurpose>
      Hierarchical Data Structures and Related Concepts for the C++ Standard Library
    </articlepurpose>
  </articleinfo>
  <section id="tree.preamble">
    <title><link linkend="tree.preamble">Hierarchical Data Structures and Related
    Concepts for the C++ Standard Library</link></title>
    <para>
      <emphasis role="bold">Bernhard Reiter and René Rivera</emphasis>
    </para>
    <variablelist>
      <title/>
      <varlistentry>
        <term>Document No.</term>
        <listitem>
          <para>
            WG21/N????=J16/??-????
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Supercedes</term>
        <listitem>
          <para>
            WG21/N2101=J16/06-0171
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Date</term>
        <listitem>
          <para>
            2013-May-03
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Project</term>
        <listitem>
          <para>
            Programming Language C++
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Reply to</term>
        <listitem>
          <para>
            René Rivera &lt;<ulink url="mailto:rrivera@acm.org">rrivera@acm.org</ulink>&gt;
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <section id="tree.preamble.introduction">
      <title><link linkend="tree.preamble.introduction">Introduction</link></title>
      <para>
        This paper proposes addition of library components covering tree structures
        and related concepts to the C++ Standard Library Technical Report 2. The
        proposal is based on work towards a Boost tree component library.
      </para>
      <para>
        The library strives to cover many of the relevant aspects within the vast
        field linked to the notion of trees in computer science.
      </para>
    </section>
    <section id="tree.preamble.motivation_and_scope">
      <title><link linkend="tree.preamble.motivation_and_scope">Motivation and Scope</link></title>
      <section id="tree.preamble.motivation_and_scope.why_is_this_important">
        <title><link linkend="tree.preamble.motivation_and_scope.why_is_this_important">Why
        is this important?</link></title>
        <para>
          This proposal is motivated by the wish to establish methods of dealing
          with hierarchical data structures in a manner that is similar to that of
          the Standard Template Library (STL) for linear ones. That is, it seeks
          to provide clear, straight-forward, versatile and comprehensive concepts,
          data structures and algorithms for trees and related structures that allow
          efficient implementation while not exposing implementation details.
        </para>
        <para>
          In particular, this proposal strives to unite types of hierarchical data
          structures that have historically been treated separately, although there
          is arguably good reason to view their role for algorithms as different
          aspects of common underlying concepts. Formally, this proposal's desired
          scope is covering all <emphasis>rooted ordered connected acyclic graphs</emphasis>.
        </para>
      </section>
      <section id="tree.preamble.motivation_and_scope.what_kinds_of_problems_does_it_a">
        <title><link linkend="tree.preamble.motivation_and_scope.what_kinds_of_problems_does_it_a">What
        kinds of problems does it address, and what kinds of programmers is it intended
        to support?</link></title>
        <para>
          Existing tree implementations as listed in the References section as well
          as the number of posts on C++ related newsgroups give an evidence of very
          general, high interest in tree and related data structures. Formalization
          of how to deal with hierarchical data structures seems to be relevant as
          programmers of any level of skill working in any given field is likely
          to need such a structure at one point.
        </para>
      </section>
      <section id="tree.preamble.motivation_and_scope.is_it_based_on_existing_practice">
        <title><link linkend="tree.preamble.motivation_and_scope.is_it_based_on_existing_practice">Is
        it based on existing practice?</link></title>
        <para>
          No; this proposal originates in an effort to create a generic tree container
          component for <ulink url="http://www.boost.org">Boost</ulink> in the course
          of <ulink url="http://code.google.com/soc/2006/boost/appinfo.html?csaid=E17EA7C7C537C131">Google
          Summer of Code™ 2006</ulink>, so at the time of this writing, implementation
          work is still unfinished and, however inspired by and striving to avoid
          past issues and such ones arising from current implementation efforts (see
          below) it is, it has not been used in practice yet.
        </para>
      </section>
      <section id="tree.preamble.motivation_and_scope.is_there_a_reference_implementat">
        <title><link linkend="tree.preamble.motivation_and_scope.is_there_a_reference_implementat">Is
        there a reference implementation?</link></title>
        <para>
          Yes; the current state is available from svn from <ulink url="http://svn.boost.org/svn/boost/sandbox/tree">http://svn.boost.org/svn/boost/sandbox/tree</ulink>.
        </para>
      </section>
    </section>
    <section id="tree.preamble.impact_on_the_standard">
      <title><link linkend="tree.preamble.impact_on_the_standard">Impact on the Standard</link></title>
      <section id="tree.preamble.impact_on_the_standard.what_does_it_depend_on_and_what_">
        <title><link linkend="tree.preamble.impact_on_the_standard.what_does_it_depend_on_and_what_">What
        does it depend on, and what depends on it?</link></title>
        <para>
          It depends on some standard library components, such as <literal moreinfo="none">std::allocator</literal>
          which is used as the default allocator template argument at some points.
          Concepts like allocators or iterators are reused and in some cases adapted.
        </para>
      </section>
      <section id="tree.preamble.impact_on_the_standard.is_it_a_pure_extension_or_does_i">
        <title><link linkend="tree.preamble.impact_on_the_standard.is_it_a_pure_extension_or_does_i">Is
        it a pure extension, or does it require changes to standard components?</link></title>
        <para>
          Most of the proposed library is a pure extension.
        </para>
        <para>
          Some extensions <literal moreinfo="none">&lt;algorithm&gt;</literal> and some extensions
          to <literal moreinfo="none">&lt;iterator&gt;</literal> are proposed.
        </para>
        <para>
          Additionally, while not proposed herein, it has sometimes been suggested
          to add a template parameter to the STL associative containers <literal moreinfo="none">set</literal>,
          <literal moreinfo="none">multiset</literal>, <literal moreinfo="none">map</literal>, and <literal moreinfo="none">multimap</literal>
          (and possibly an argument to their constructors) specifying a policy for
          storing elements, or, more concretely, what tree. The balancers presented
          in this proposal would lend themselves to such use. Indicating what type
          of balanced hierarchy to use for associative containers would create some
          amount of symmetry to TR1's <literal moreinfo="none">unordered</literal> containers that
          allow specification of a hash functor; it is however a momentous decision
          in which position to put such a parameter. The same position as for <literal moreinfo="none">unordered</literal>
          containers (before the comparison functor) would require changes in existing
          code; making it the last parameter (after the allocator) would allow existing
          code to remain unchanged, but seems somewhat irritating when compared to
          <literal moreinfo="none">unordered</literal> containers.
        </para>
      </section>
      <section id="tree.preamble.impact_on_the_standard.can_it_be_implemented_using_toda">
        <title><link linkend="tree.preamble.impact_on_the_standard.can_it_be_implemented_using_toda">Can
        it be implemented using today's compilers, or does it require language features
        that will only be available as part of C++11</link></title>
        <para>
          It can be, and partly has been, implemented with today's compilers.
        </para>
        <para>
          Note that it might be worthwhile to investigate if the present Container
          concept should be modified so that it only covers the requirements as of
          paragraph 2 of section <ulink url="#tr.hierarchy.req">[tr.hierarchy.req]</ulink>
          of this proposal, which correspond to the current Container concept with
          the exception of any expressions that implicitly assume linear internal
          structure and outsource those to a "Linear Container" concept
          as similarly formalized in the <ulink url="http://boost.org/libs/range/doc/range.html">Boost
          Range concept</ulink> (<ulink url="http://boost.org/libs/range/doc/range.html">http://boost.org/libs/range/doc/range.html</ulink>)
          externally to the Standard.
        </para>
      </section>
    </section>
    <section id="tree.preamble.important_design_decisions">
      <title><link linkend="tree.preamble.important_design_decisions">Important Design
      Decisions</link></title>
      <section id="tree.preamble.important_design_decisions.why_did_you_choose_the_specific_">
        <title><link linkend="tree.preamble.important_design_decisions.why_did_you_choose_the_specific_">Why
        did you choose the specific design that you did?</link></title>
        <para>
          One of the most important assets of the present design is the cursor concept
          as a hierarchical continuation to the STL's iterator concept, and the externally
          defined range concept. Among their benefits, cursors allow to handle both
          client data access, by dereference, and subtree access while hiding the
          normally underlying node structure and providing a uniform interface to
          algorithms that are thus enabled to deal with a number of different kinds
          of trees. On the other hand, this abstraction achieves independence of
          implementation details, such as nodes for storage in many cases, allowing
          the underlying concepts to be applicable to other possible implementations
          as well.
        </para>
      </section>
      <section id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid">
        <title><link linkend="tree.preamble.important_design_decisions.what_alternatives_did_you_consid">What
        alternatives did you consider, and what are the tradeoffs?</link></title>
        <bridgehead renderas="sect5" id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.h0">
          <phrase id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.trees_of_trees"/><link linkend="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.trees_of_trees">Trees
          of trees</link>
        </bridgehead>
        <para>
          Trees, being recursively defined data structures, seem to somewhat lend
          themselves to recursive implementation, i.e. declaring them in a way so
          they consist of a client value part and a certain number of trees in turn
          (as e.g. in case of <link linkend="haas">[haas]</link>). Such an approach
          would allow for uniform treatment of the subtrees, but would duplicate
          allocators and imply structure that need not be present. The tree, like
          existing STL containers, should be responsible for data representation
          and storage.
        </para>
        <bridgehead renderas="sect5" id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.h1">
          <phrase id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.augmentors_balancers_as_policies"/><link linkend="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.augmentors_balancers_as_policies">Augmentors/balancers
          as policies</link>
        </bridgehead>
        <para>
          Inspired by <link linkend="austern">[austern]</link> and <link linkend="dreizin">[dreizin]</link>,
          the original approach undertaken when working on the reference implementation
          was to pass policy template arguments to template class <literal moreinfo="none">binary_tree</literal>.
          While reproducing the (otherwise unbalanced) tree/cursor interface seemed
          logical at first, it turned out that this was conceptually not entirely
          clean, as e.g. it preferred one type of linear order, namely inorder, over
          the others by putting such strong focus on inorder-invariant balancing
          and its possible applications; also, balancing and augmenting metadata
          would inevitably have been much more visible. It seemed more appropriate
          to have different balancing adaptors and augmenting adaptors that would
          replicate the interface to do that work.
        </para>
      </section>
      <section id="tree.preamble.important_design_decisions.what_are_the_consequences_of_you">
        <title><link linkend="tree.preamble.important_design_decisions.what_are_the_consequences_of_you">What
        are the consequences of your choices, for users and implementors?</link></title>
        <para>
          As focus was put on versatility and comprehensiveness, we hope users will
          find this a powerful framework that covers most important aspects of dealing
          with hierarchical data structures in a rather intuitive way, once they
          have adapted to the notion of cursors which, although being the interface
          relevant portion of the well-known node implementation of trees, partly
          diverge in their usage from plain node objects.
        </para>
        <para>
          Wherever reasonably possible, strong time complexity guarantees are given,
          which mostly, while trying not to require much space overhead, demand implementations
          that make use of any time and space saving techniques available (e.g. using
          arrays for both children of a binary tree node, see e.g. <link linkend="austern">[austern]</link>),
          which may partly restrict implementors to one "proper" way of
          doing things.
        </para>
      </section>
      <section id="tree.preamble.important_design_decisions.what_decisions_are_left_up_to_im">
        <title><link linkend="tree.preamble.important_design_decisions.what_decisions_are_left_up_to_im">What
        decisions are left up to implementors?</link></title>
        <para>
          Most of the requirements for the library components presented in this proposal
          are rather tightly formulated in order to allow for them being both efficient
          and general enough. It is however hoped that the conceptual abstraction
          of hierarchies and cursors may be of general use, also allowing for more
          specific implementations where required (although probably not as part
          of the library; ideally comparable to the role of containers and iterators
          in modern C++ code).
        </para>
      </section>
      <section id="tree.preamble.important_design_decisions.if_there_are_any_similar_librari">
        <title><link linkend="tree.preamble.important_design_decisions.if_there_are_any_similar_librari">If
        there are any similar libraries in use, how do their design decisions compare
        to yours?</link></title>
        <para>
          Trees, having attracted much attention in the C++ community, are found
          in various implementations and as subjects of a number of papers. Contrary
          to the present proposal, practically all of them deal either with trees
          as used for sorted associative containers (with logarithmic time complexity
          for more relevant operations, achieved by some sort of balancing; examples
          are <link linkend="dreizin">[dreizin]</link>, <link linkend="ekman">[ekman]</link>
          and <link linkend="karas">[karas]</link>; plus, most current STL implementations
          use a red-black tree as their associative containers' base) or with what
          we call "external" hierarchies in the following (whose structure
          is dictated e.g. by a file system directory tree, an XML file or an AST;
          see e.g. <link linkend="gottschlich">[gottschlich]</link>, <link linkend="haas">[haas]</link>,
          <link linkend="parent">[parent]</link> and <link linkend="peeters">[peeters]</link>),
          but rarely both fields of application.
        </para>
        <para>
          Approaches as found in <link linkend="austern">[austern]</link> or <link linkend="mirwaisi">[mirwaisi]</link> go some steps further and have provided
          valuable inspiration for this project, but still do not formalize anything
          similar as the cursor-based interface in this proposal for dealing with
          a tree's contents.
        </para>
        <para>
          The <ulink url="http://www.boost.org/libs/graph/">BGL</ulink>, finally,
          deals with graphs that are even more general than hierarchical ones, which
          does not allow them to profit from specific hierarchy properties as much
          as the ones presented in this proposal. Making cursors logical extensions
          of iterators would probably also have been more difficult with a BGL-based
          approach.
        </para>
      </section>
    </section>
    <section id="tree.preamble.future_directions">
      <title><link linkend="tree.preamble.future_directions">Future Directions</link></title>
      <para>
        While it is hoped that the current proposal somewhat reunites balanced binary
        trees, B-trees and "external" hierarchies, which should also facilitate
        work with some higher-level structures (e.g. n-ary trees to implement tries),
        some of those higher-level components might be an interesting feature to
        add to the library, such as patricia tries or ternary search tries.
      </para>
    </section>
  </section>
  <section role="std_proposal" id="tree.proposal">
<title><link linkend="tree.proposal">Proposed Text</link></title>
  <note>
    <para>
      Notes that are not part of the proposed text appear in gray boxes.
    </para>
  </note>
  <section role="std_section" id="tree.proposal.containers" label="23" label-style="no-parent">
<title><link linkend="tree.proposal.containers">Container library <phrase role="std_section_label">[containers]</phrase></link></title> <section role="std_section" id="tree.proposal.hierarchy" label="7">
<title><link linkend="tree.proposal.hierarchy">Hierarchy
  containers <phrase role="std_section_label">[hierarchy]</phrase></link></title>

  <section id="tree.req">
    <title><link linkend="tree.req">Hierarchy containers requirements <phrase role="std_section_label">[hierarchy.req]</phrase></link></title>
    <simplesect role="std_requisite"><para>
      A hierarchy is an object that stores a finite set of objects, all of the same
      type, in a hierarchical manner. Hierarchies introduce a cursor concept for
      navigation instead of iterators. The library provides two kinds of native hierarchies:
      <literal moreinfo="none">binary_tree</literal>, and <literal moreinfo="none">nary_tree</literal>, along with
      hierarchy-yielding hierarchy adaptors <literal moreinfo="none">forest_tree</literal>, and
      <literal moreinfo="none">multiway_tree</literal>.
    </para>
    </simplesect> <simplesect role="std_requisite"><para>
      Hierarchy containers conform to the requirements of Containers ([lib.container.requirements]),
      except that the expressions in Table 1 are not required to be valid, where
      a and b denote values of a type X, and X is a hierarchy container class:
    </para>
    <table frame="all" id="tree.req.table1">
      <title>Container requirements that are not required for hierarchy containers</title>
      <tgroup cols="1">
        <thead>
          <row>
            <entry>
              <para>
                unsupported expression
              </para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">X::iterator</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">X::const_iterator</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">X::reverse_iterator</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">X::const_reverse_iterator</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.begin()</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.end()</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.rbegin()</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.rend()</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a &lt; b</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a &gt; b</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a &lt;= b</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a &gt;= b</literal>
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>
      Non-constant complexity requirements in this clause are stated in one of a
      number of possible different ways: unless specified otherwise, they are expressed
      in terms of the number of operations <literal moreinfo="none">n</literal>, which stands for
      the total number of elements in the hierarchy; in some cases, however, they
      are stated in terms of another value.
    </para>
    </simplesect> <simplesect role="std_requisite"><para>
      In Table 2: <literal moreinfo="none">X</literal> denotes a hierarchy class containing objects
      of type <literal moreinfo="none">T</literal> and <literal moreinfo="none">a</literal> denotes a value of type
      <literal moreinfo="none">X</literal>.
    </para>
    <table frame="all" id="tree.req.table2">
      <title>Hierarchy requirements (in addition to container)</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>
              <para>
                expression
              </para>
            </entry>
            <entry>
              <para>
                return type
              </para>
            </entry>
            <entry>
              <para>
                assertion/note<sbr/> pre/post-condition
              </para>
            </entry>
            <entry>
              <para>
                complexity
              </para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">X::cursor</literal>
              </para>
            </entry>
            <entry>
              <para>
                cursor type pointing to <literal moreinfo="none">T</literal>
              </para>
            </entry>
            <entry>
              <para>
                any cursor category
              </para>
            </entry>
            <entry>
              <para>
                compile time
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">X::const_cursor</literal>
              </para>
            </entry>
            <entry>
              <para>
                cursor type pointing to <literal moreinfo="none">const T</literal>
              </para>
            </entry>
            <entry>
              <para>
                any cursor category
              </para>
            </entry>
            <entry>
              <para>
                compile time
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.root()</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">iterator</literal> for mutable <literal moreinfo="none">a</literal>;<sbr/>
                <literal moreinfo="none">const_iterator</literal> for constant <literal moreinfo="none">a</literal>
              </para>
            </entry>
            <entry>
              <para>
                 
              </para>
            </entry>
            <entry>
              <para>
                constant
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.croot()</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">const_iterator</literal>
              </para>
            </entry>
            <entry>
              <para>
                 
              </para>
            </entry>
            <entry>
              <para>
                constant
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.shoot()</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">iterator</literal> for mutable <literal moreinfo="none">a</literal>;<sbr/>
                <literal moreinfo="none">const_iterator</literal> for constant <literal moreinfo="none">a</literal>
              </para>
            </entry>
            <entry>
              <para>
                 
              </para>
            </entry>
            <entry>
              <para>
                (Note A)
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.cshoot()</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">const_iterator</literal>
              </para>
            </entry>
            <entry>
              <para>
                 
              </para>
            </entry>
            <entry>
              <para>
                (Note A)
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">typename X::template rebind&lt;U&gt;::other</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">Y</literal>
              </para>
            </entry>
            <entry>
              <para>
                For all <literal moreinfo="none">U</literal> (including <literal moreinfo="none">T</literal>), <literal moreinfo="none">Y::template
                rebind&lt;T&gt;::other</literal> is <literal moreinfo="none">X</literal>.
              </para>
            </entry>
            <entry>
              <para>
                compile time
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>
      Notes: Those entries marked "(Note A)" should have at worst linear
      complexity. See the individual hierarchy containers for specific complexity.
    </para>
    </simplesect> <simplesect role="std_requisite"><para>
      <literal moreinfo="none">root()</literal> and <literal moreinfo="none">croot()</literal> return a cursor which
      is the on-top value for the hierarchy. <literal moreinfo="none">shoot()</literal> and <literal moreinfo="none">cshoot()</literal>
      return a cursor which is the past-the-end value that is found one past the
      hierarchy's rightmost element. If the hierarchy is empty, then <literal moreinfo="none">root()
      == shoot();</literal>
    </para>
    </simplesect> <simplesect role="std_requisite"><para>
      Copy constructors for all hierarchy types defined in this clause copy the allocator
      argument from their respective first parameters. All other constructors for
      these hierarchy types take an <literal moreinfo="none">Allocator&amp;</literal> argument (20.1.5).
      A copy of this argument is used for any memory allocation performed, by these
      constructors and by all member functions, during the lifetime of each hierarchy
      object. In all hierarchy types defined in this clause, the member <literal moreinfo="none">get_allocator()</literal>
      returns a copy of the Allocator object used to construct the hierarchy.
    </para>
    </simplesect> <simplesect role="std_requisite"><para>
      The member class template <literal moreinfo="none">rebind</literal> in the table above is effectively
      a typedef template: if the name <literal moreinfo="none">Hierarchy</literal> is bound to <literal moreinfo="none">SomeHierarchy&lt;T&gt;</literal>,
      then <literal moreinfo="none">Hierarchy::rebind&lt;U&gt;::other</literal> is the same type
      as <literal moreinfo="none">SomeHierarchy&lt;U&gt;</literal>. Additionally, because of the
      related assertion, given <literal moreinfo="none">SomeHierarchy&lt;T,R0,...,Rn&gt;</literal>
      for all template arguments present is bound to the name <literal moreinfo="none">Hierarchy</literal>,
      then <literal moreinfo="none">Hierarchy::rebind&lt;U&gt;::other</literal> is the same type
      as <literal moreinfo="none">SomeHierarchy&lt;U,S0,...,Sn&gt;</literal> such that the types
      <literal moreinfo="none">S0</literal> through <literal moreinfo="none">Sn</literal> are the same as <literal moreinfo="none">R0</literal>
      through <literal moreinfo="none">Rn</literal>, respectively, when <literal moreinfo="none">U</literal> is the
      same type as <literal moreinfo="none">T</literal>.
    </para>
    </simplesect> <simplesect role="std_requisite"><para>
      A hierarchy satisfying the requirements shown in Table 3 is called a <emphasis>mutable
      hierarchy</emphasis>. In Table 3, <literal moreinfo="none">X</literal> denotes a hierarchy
      class, <literal moreinfo="none">a</literal> denotes a value of <literal moreinfo="none">X</literal>, <literal moreinfo="none">c</literal>
      denotes a valid, non-on-top cursor satisfying input cursor requirements, <literal moreinfo="none">p</literal>
      denotes a valid, non-on-top cursor to <literal moreinfo="none">a</literal>, <literal moreinfo="none">q</literal>
      denotes a valid, dereferenceable cursor to <literal moreinfo="none">a</literal>, and <literal moreinfo="none">t</literal>
      denotes a value of <literal moreinfo="none">X::value_type</literal>.
    </para>
    <table frame="all" id="tree.req.table3">
      <title>Mutable hierarchy requirements</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>
              <para>
                expression
              </para>
            </entry>
            <entry>
              <para>
                return type
              </para>
            </entry>
            <entry>
              <para>
                assertion/note<sbr/> pre/post-condition
              </para>
            </entry>
            <entry>
              <para>
                complexity
              </para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.insert(p,t)</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">cursor</literal>
              </para>
            </entry>
            <entry>
              <para>
                inserts a copy of <literal moreinfo="none">t</literal> before <literal moreinfo="none">p</literal>
              </para>
            </entry>
            <entry>
              <para>
                (Note A)
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.clear(q)</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">void</literal>
              </para>
            </entry>
            <entry>
              <para>
                deletes the subtree of <literal moreinfo="none">q</literal> and the element <literal moreinfo="none">q</literal>
                points to.<sbr/> pre: <literal moreinfo="none">q</literal> is dereferenceable.
              </para>
            </entry>
            <entry>
              <para>
                Should be at worst linear in the the number of elements in the subtree
                of <literal moreinfo="none">q</literal> plus the distance to <literal moreinfo="none">q</literal>'s
                parent's <literal moreinfo="none">end()</literal>.
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.clear()</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">void</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">while (a.size()) clear(a.begin());</literal><sbr/> post:
                <literal moreinfo="none">a.size() == 0</literal>
              </para>
            </entry>
            <entry>
              <para>
                (Note A)
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>
      Notes: Those entries marked "(Note A)" should have at worst linear
      complexity. See the individual hierarchy containers for specific complexity.
    </para>
    </simplesect> <simplesect role="std_requisite"><para>
      The cursor returned from <literal moreinfo="none">a.insert(p,t)</literal> points to the copy
      of <literal moreinfo="none">t</literal> inserted into <literal moreinfo="none">a</literal>. Its parent cursor
      is the same as that of <literal moreinfo="none">p</literal>.
    </para>
    </simplesect>
  </section>
  <section id="tree.plain">
    <title><link linkend="tree.plain">Plain hierarchies <phrase role="std_section_label">[hierarchy.plain]</phrase></link></title>
    <simplesect role="std_requisite"><para>
      A hierarchy is called plain hierarchy if its cursor and const_cursor types
      satisfy the requirements of a plain cursor.
    </para>
    </simplesect> <simplesect role="std_requisite"><para>
      The library provides one native kind of plain hierarchy, nary_tree, and a hierarchy
      adaptor that in turn yields a plain hierarchy, forest_tree.
    </para>
    </simplesect> <simplesect role="std_requisite"><para>
      For a mutable plain hierarchy, the following expressions as shown in Table
      4, are additionally required to be valid:
    </para>
    <table frame="all" id="tree.plain.table4">
      <title>Plain hierarchy requirements</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>
              <para>
                expression
              </para>
            </entry>
            <entry>
              <para>
                return type
              </para>
            </entry>
            <entry>
              <para>
                assertion/note<sbr/> pre/post-condition
              </para>
            </entry>
            <entry>
              <para>
                complexity
              </para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.insert(p,c)</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">cursor</literal>
              </para>
            </entry>
            <entry>
              <para>
                inserts a copy of the subtree of <literal moreinfo="none">c</literal> before <literal moreinfo="none">p</literal>.<sbr/>
                pre: <literal moreinfo="none">c</literal> is dereferenceable.
              </para>
            </entry>
            <entry>
              <para>
                Should be at worst linear in the the number of elements in the subtree
                of <literal moreinfo="none">c</literal> plus the distance to <literal moreinfo="none">p</literal>'s
                parent's <literal moreinfo="none">end()</literal>.
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.insert_above(p,t)</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">cursor</literal>
              </para>
            </entry>
            <entry>
              <para>
                inserts a copy of <literal moreinfo="none">t</literal> as child of <literal moreinfo="none">p</literal>'s
                parent and new parent of <literal moreinfo="none">p</literal> and its siblings.<sbr/>
                pre: <literal moreinfo="none">c</literal> is dereferenceable.
              </para>
            </entry>
            <entry>
              <para>
                Linear in the the number <literal moreinfo="none">p</literal>'s siblings.
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    </simplesect> <simplesect role="std_requisite"><para>
      The cursor returned from <literal moreinfo="none">a.insert(p,c)</literal> points to the copy
      of the element that <literal moreinfo="none">c</literal> points to, inserted into <literal moreinfo="none">a</literal>.
      Its parent cursor is the same as that of <literal moreinfo="none">p</literal>.
    </para>
    </simplesect>
  </section>
  <section id="tree.multiway">
    <title><link linkend="tree.multiway">Multiway hierarchies <phrase role="std_section_label">[hierarchy.multiway]</phrase></link></title>
    <simplesect role="std_requisite"><para>
      A hierarchy is called multiway hierarchy if its <literal moreinfo="none">cursor</literal> and
      <literal moreinfo="none">const_cursor</literal> types satisfy the requirements of a multiway
      cursor.
    </para>
    </simplesect> <simplesect role="std_requisite"><para>
      The library provides one native kind of multiway hierarchy, <literal moreinfo="none">binary_tree</literal>,
      and a hierarchy adaptor that in turn yields a multiway hierarchy, <literal moreinfo="none">multiway_tree</literal>.
    </para>
    </simplesect> <simplesect role="std_requisite"><para>
      For a mutable multiway hierarchy, the semantics of some expressions from Table
      3 are modified as shown in Table 5.
    </para>
    <table frame="all" id="tree.multiway.table5">
      <title>Multiway hierarchy requirements</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>
              <para>
                expression
              </para>
            </entry>
            <entry>
              <para>
                return type
              </para>
            </entry>
            <entry>
              <para>
                assertion/note<sbr/> pre/post-condition
              </para>
            </entry>
            <entry>
              <para>
                complexity
              </para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">a.clear(q)</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">void</literal>
              </para>
            </entry>
            <entry>
              <para>
                deletes the subtree of <literal moreinfo="none">q</literal>.<sbr/> If <literal moreinfo="none">q</literal>
                is dereferenceable, the expression also deletes the element <literal moreinfo="none">q</literal>
                points to.<sbr/> If <literal moreinfo="none">q</literal> is past-the-end, the expression
                deletes the element <literal moreinfo="none">q</literal>'s predecessor points to.<sbr/>
                If after either of these steps <literal moreinfo="none">q</literal> has only a non-empty
                past-the-end child, that child's children become <literal moreinfo="none">q</literal>'s
                children instead. Finally, that child is deleted.<sbr/> pre: <literal moreinfo="none">q</literal>
                is internal.
              </para>
            </entry>
            <entry>
              <para>
                Should be at worst linear in the the number of elements in the subtree
                of <literal moreinfo="none">c</literal> plus the distance to <literal moreinfo="none">p</literal>'s
                parent's <literal moreinfo="none">end()</literal>.
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    </simplesect>
  </section>
  <section id="tree.tree">
    <title><link linkend="tree.tree">Trees <phrase role="std_section_label">[hierarchy.tree]</phrase></link></title>
    <simplesect role="std_requisite"><para>
      Headers <literal moreinfo="none">&lt;binary_tree&gt;</literal>, <literal moreinfo="none">&lt;nary_tree&gt;</literal>,
      <literal moreinfo="none">&lt;forest_tree&gt;</literal>, and <literal moreinfo="none">&lt;multiway_tree&gt;</literal>.
    </para>
    <para>
      <emphasis role="bold">Header <literal moreinfo="none">&lt;binary_tree&gt;</literal> synopsis</emphasis>
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase> <phrase role="special">=</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
    <para>
      <emphasis role="bold">Header <literal moreinfo="none">&lt;nary_tree&gt;</literal> synopsis</emphasis>
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase> <phrase role="special">=</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
              <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
    <para>
      <emphasis role="bold">Header <literal moreinfo="none">&lt;forest_tree&gt;</literal> synopsis</emphasis>
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">forest_tree</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
              <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
    <para>
      <emphasis role="bold">Header <literal moreinfo="none">&lt;multiway_tree&gt;</literal> synopsis</emphasis>
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">multiway_tree</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
    </simplesect>
<section id="tree.tree.bintree">
      <title><link linkend="tree.tree.bintree">Class template <literal moreinfo="none">binary_tree</literal>
      <phrase role="std_section_label">[hierarchy.bintree]</phrase></link></title>
      <section id="tree.tree.bintree.overview">
        <title><link linkend="tree.tree.bintree.overview">Class template <literal moreinfo="none">binary_tree</literal>
        overview <phrase role="std_section_label">[hiearchy.bintree.overview]</phrase></link></title>
        <para>
          A <literal moreinfo="none">binary_tree</literal> is a kind of hierarchy that satisfies
          multiway hierarchy requirements. Additionally, it supports (inorder-invariant)
          cursor rotation. Descriptions are provided here only for operations on
          <literal moreinfo="none">binary_tree</literal> that are not described in one of these tables
          or for operations where there is additional semantic information.
        </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase> <phrase role="special">=</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">class</phrase> <phrase role="identifier">binary_tree</phrase>
  <phrase role="special">{</phrase>
  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="comment">// types:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">T</phrase>                                             <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Alloc</phrase>                                         <phrase role="identifier">allocator_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">pointer</phrase>              <phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_pointer</phrase>        <phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">reference</phrase>            <phrase role="identifier">reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_reference</phrase>      <phrase role="identifier">const_reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">size_type</phrase>            <phrase role="identifier">size_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">difference_type</phrase>      <phrase role="identifier">difference_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">U</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">rebind</phrase> <phrase role="special">{</phrase>
      <phrase role="keyword">typedef</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">U</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="keyword">template</phrase> <phrase role="identifier">rebind</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">other</phrase> <phrase role="special">&gt;</phrase>
        <phrase role="identifier">other</phrase><phrase role="special">;</phrase>
    <phrase role="special">};</phrase>

    <phrase role="comment">// construct/copy/destroy:</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">binary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">allocator_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">binary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">,</phrase>
        <phrase role="identifier">allocator_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
    <phrase role="identifier">binary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="special">~</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase>
      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">allocator_type</phrase> <phrase role="identifier">get_allocator</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// cursors:</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">root</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">croot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase> <phrase role="keyword">const</phrase><phrase role="special">();</phrase>

    <phrase role="comment">// capacity:</phrase>
    <phrase role="keyword">bool</phrase>      <phrase role="identifier">empty</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">max_size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// modifiers:</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">rotate</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
  <phrase role="special">};</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="comment">// specialized algorithms:</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
      </section>
      <section id="tree.tree.bintree.types">
        <title><link linkend="tree.tree.bintree.types"><literal moreinfo="none">binary_tree</literal>
        types <phrase role="std_section_label">[hierarchy.bintree.types]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis> <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis> <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_requisite"><para>
          Both <literal moreinfo="none">cursor</literal> and <literal moreinfo="none">const_cursor</literal> have
          to fulfill the multiway cursor ([cursor.flavors]) and ascending random
          access cursor ([ascending.random.access.cursors]) requirements.
        </para>
        </simplesect> <simplesect role="std_requisite"><para>
          Additionally, for any instance a of either type <literal moreinfo="none">cursor</literal>
          or <literal moreinfo="none">const_cursor</literal>, <literal moreinfo="none">a.max_size() == 1</literal>.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.bintree.cons">
        <title><link linkend="tree.tree.bintree.cons"><literal moreinfo="none">binary_tree</literal>
        constructors, copy, and assignment <phrase role="std_section_label">[hierarchy.bintree.cons]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">explicit</phrase> <phrase role="identifier">binary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">allocator_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">binary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">,</phrase>
    <phrase role="identifier">allocator_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
<phrase role="identifier">binary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Complexity:</emphasis> The constructor <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase>
          <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase>
          <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
          <phrase role="identifier">vector</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">)</phrase></computeroutput> makes only <literal moreinfo="none">N</literal> calls
          to the copy constructor of <literal moreinfo="none">T</literal> (where <literal moreinfo="none">N</literal>
          is the number of elements in <literal moreinfo="none">subtree</literal>) and no reallocations
          if the cursor <literal moreinfo="none">subtree</literal> is of (either descending or ascending)
          forward, bidirectional, or random access categories. It does at most <literal moreinfo="none">2N</literal>
          calls to the copy constructor of <literal moreinfo="none">T</literal> and <literal moreinfo="none">logN</literal>
          reallocations if they are just cursors, since it is impossible to determine
          the size of <literal moreinfo="none">subtree</literal> and then do copying.
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Effects:</emphasis>
        </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase> <phrase role="identifier">i</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">root</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase> <phrase role="special">*</phrase><phrase role="identifier">i</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect>
      </section>
      <section id="tree.tree.bintree.cursors">
        <title><link linkend="tree.tree.bintree.cursors"><literal moreinfo="none">binary_tree</literal>
        cursors <phrase role="std_section_label">[hierarchy.bintree.cursors]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Complexity:</emphasis> constant
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">();</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Returns:</emphasis> A cursor to the <literal moreinfo="none">binary_tree</literal>'s
          first element in inorder (see [tr.order.iterators], §4).
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Complexity:</emphasis> constant.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.bintree.modifiers">
        <title><link linkend="tree.tree.bintree.modifiers"><literal moreinfo="none">binary_tree</literal>
        modifiers <phrase role="std_section_label">[hierarchy.bintree.modifiers]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase> <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Notes:</emphasis> Does not affect the validity of cursors and
          references.
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Effect:</emphasis> Let <literal moreinfo="none">b be =a</literal>'s parent; if
          <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">b</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">b</phrase><phrase role="special">.</phrase><phrase role="identifier">max_size</phrase><phrase role="special">()</phrase></computeroutput>, insert a copy of <literal moreinfo="none">t</literal>
          before <literal moreinfo="none">p</literal>, as child of <literal moreinfo="none">b</literal>; Otherwise,
          if <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">empty</phrase><phrase role="special">()</phrase></computeroutput>,
          insert a copy of <literal moreinfo="none">t</literal> as child of <literal moreinfo="none">a</literal>;
          and if <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">!</phrase><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">empty</phrase><phrase role="special">()</phrase></computeroutput>, insert a copy of <literal moreinfo="none">t</literal>
          as parent of <literal moreinfo="none">a</literal>'s current child, as new child of <literal moreinfo="none">a</literal>.
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          Complexity: constant
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">cursor</phrase> <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Notes:</emphasis> Does not affect the validity of cursors and
          references.
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Effects:</emphasis> as above, substituting <literal moreinfo="none">InputCursor
          subtree</literal> to insert instead of <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">value_type</phrase>
          <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase>
          <phrase role="identifier">x</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Complexity:</emphasis> linear in the number of elements in subtree.
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">rotate</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Precondition:</emphasis> position and its parent are internal
          and non-on-top
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Effects:</emphasis> Performs a left tree rotation around the
          parent of position if <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">parity</phrase><phrase role="special">()</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase></computeroutput>
          or a right tree rotation if <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">parity</phrase><phrase role="special">()</phrase> <phrase role="special">==</phrase> <phrase role="number">1</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Postcondition:</emphasis> If <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">par</phrase>
          <phrase role="special">==</phrase> <phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">parity</phrase><phrase role="special">()</phrase></computeroutput> as of before the rotation, then, after
          the rotation:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()</phrase></computeroutput> yields the same value it yielded
              before the rotation
            </para>
          </listitem>
          <listitem>
            <para>
              <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">parity</phrase><phrase role="special">()</phrase>
              <phrase role="special">==</phrase> <phrase role="special">!</phrase><phrase role="identifier">par</phrase></computeroutput>
            </para>
          </listitem>
          <listitem>
            <para>
              <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*(((</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[</phrase><phrase role="identifier">par</phrase><phrase role="special">]).</phrase><phrase role="identifier">begin</phrase><phrase role="special">())</phrase></computeroutput> yields what <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*(</phrase><phrase role="identifier">p</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">())</phrase></computeroutput>
              yielded before, if <literal moreinfo="none">p</literal> was <literal moreinfo="none">position</literal>'s
              parent
            </para>
          </listitem>
          <listitem>
            <para>
              <literal moreinfo="none">position</literal>'s parent's value is what <literal moreinfo="none">position</literal>'s
              parent's parent's value yielded before. The ancestors of that cursor,
              and their structure, remain unchanged
            </para>
          </listitem>
          <listitem>
            <para>
              <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[!</phrase><phrase role="identifier">par</phrase><phrase role="special">]</phrase></computeroutput>'s subtree is what <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[!</phrase><phrase role="identifier">par</phrase><phrase role="special">]</phrase></computeroutput>'s
              was before.
            </para>
          </listitem>
          <listitem>
            <para>
              <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">((</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()[!</phrase><phrase role="identifier">par</phrase><phrase role="special">]).</phrase><phrase role="identifier">begin</phrase><phrase role="special">())\[</phrase><phrase role="identifier">par</phrase><phrase role="special">]</phrase></computeroutput>'s subtree is what <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">(</phrase><phrase role="identifier">p</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[!</phrase><phrase role="identifier">par</phrase><phrase role="special">]</phrase></computeroutput>'s
              was before, if <literal moreinfo="none">p</literal> was <literal moreinfo="none">position</literal>'s
              parent.
            </para>
          </listitem>
          <listitem>
            <para>
              <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">((</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()[!</phrase><phrase role="identifier">par</phrase><phrase role="special">]).</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[</phrase><phrase role="identifier">par</phrase><phrase role="special">]</phrase></computeroutput>'s subtree is what <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[!</phrase><phrase role="identifier">par</phrase><phrase role="special">]</phrase></computeroutput>'s
              was before.
            </para>
          </listitem>
        </itemizedlist>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Complexity:</emphasis> constant
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Notes:</emphasis> Does not affect the validity of cursors and
          references. Tree rotations are important inorder-preserving (see [tr.order.iterators]
          §4) operations on binary trees that are especially required by balancers.
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Notes:</emphasis> Invalidates only the cursors and references
          to the erased elements.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.bintree.special">
        <title><link linkend="tree.tree.bintree.special"><literal moreinfo="none">binary_tree</literal>
        specialized algorithms <phrase role="std_section_label">[hierarchy.bintree.special]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
              <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Effects:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">)</phrase></computeroutput>;
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">inorder_first</phrase><phrase role="special">())</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Complexity:</emphasis> constant
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">inorder_cfirst</phrase><phrase role="special">())</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Complexity:</emphasis> constant
        </para>
        </simplesect>
      </section>
    </section>
    <section id="tree.tree.narytree">
      <title><link linkend="tree.tree.narytree">Class template <literal moreinfo="none">nary_tree</literal>
      <phrase role="std_section_label">[narytree]</phrase></link></title>
      <section id="tree.tree.narytree.synopsis">
        <title><link linkend="tree.tree.narytree.synopsis"><literal moreinfo="none">nary_tree</literal>
        overview <phrase role="std_section_label">[narytree.overview]</phrase></link></title>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase> <phrase role="special">=</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">class</phrase> <phrase role="identifier">nary_tree</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="comment">// types:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">T</phrase>                                             <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Alloc</phrase>                                         <phrase role="identifier">allocator_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">pointer</phrase>              <phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_pointer</phrase>        <phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">reference</phrase>            <phrase role="identifier">reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_reference</phrase>      <phrase role="identifier">const_reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">size_type</phrase>            <phrase role="identifier">size_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">difference_type</phrase>      <phrase role="identifier">difference_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">U</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">rebind</phrase> <phrase role="special">{</phrase>
      <phrase role="keyword">typedef</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">U</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="keyword">template</phrase> <phrase role="identifier">rebind</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">other</phrase> <phrase role="special">&gt;</phrase>
        <phrase role="identifier">other</phrase><phrase role="special">;</phrase>
    <phrase role="special">};</phrase>

    <phrase role="comment">// construct/copy/destroy:</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">allocator_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">,</phrase>
        <phrase role="identifier">allocator_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
    <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="special">~</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase>
      <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">allocator_type</phrase> <phrase role="identifier">get_allocator</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// cursors:</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">root</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">croot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase> <phrase role="keyword">const</phrase><phrase role="special">();</phrase>

    <phrase role="comment">// capacity:</phrase>
    <phrase role="keyword">bool</phrase>      <phrase role="identifier">empty</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">max_size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>

    <phrase role="comment">// modifiers:</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
  <phrase role="special">};</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="comment">// specialized algorithms:</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
      </section>
      <section id="tree.tree.narytree.types">
        <title><link linkend="tree.tree.narytree.types"><literal moreinfo="none">nary_tree</literal>
        types <phrase role="std_section_label">[narytree.types]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          Both <literal moreinfo="none">cursor</literal> and <literal moreinfo="none">const_cursor</literal> have
          to fulfill the plain cursor ([cursor.flavors]) and ascending random access
          cursor ([ascending.random.access.cursors]) requirements.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.narytree.cons">
        <title><link linkend="tree.tree.narytree.cons"><literal moreinfo="none">nary_tree</literal>
        constructors, copy, and assignment <phrase role="std_section_label">[narytree.cons]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">explicit</phrase> <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">allocator_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">,</phrase>
    <phrase role="identifier">allocator_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
<phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Complexity:</emphasis> The constructor <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase>
          <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase>
          <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
          <phrase role="identifier">vector</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">)</phrase></computeroutput> makes only <literal moreinfo="none">N</literal> calls
          to the copy constructor of <literal moreinfo="none">T</literal> (where <literal moreinfo="none">N</literal>
          is the number of elements in <literal moreinfo="none">subtree</literal>) and no reallocations
          if the cursor <literal moreinfo="none">subtree</literal> is of (either descending or ascending)
          forward, bidirectional, or random access categories. It does at most <literal moreinfo="none">2N</literal>
          calls to the copy constructor of <literal moreinfo="none">T</literal> and <literal moreinfo="none">logN</literal>
          reallocations if they are just cursors, since it is impossible to determine
          the size of <literal moreinfo="none">subtree</literal> and then do copying.
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Effects:</emphasis>
        </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase> <phrase role="identifier">i</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">root</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase> <phrase role="special">*</phrase><phrase role="identifier">i</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect>
      </section>
      <section id="tree.tree.narytree.cursors">
        <title><link linkend="tree.tree.narytree.cursors"><literal moreinfo="none">nary_tree</literal>
        cursors <phrase role="std_section_label">[narytree.cursors]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Complexity:</emphasis> constant
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">();</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Returns:</emphasis> A cursor to the nary_tree's first element
          in inorder (see [order.iterators], §4).
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Complexity:</emphasis> constant.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.narytree.capacity">
        <title><link linkend="tree.tree.narytree.capacity"><literal moreinfo="none">nary_tree</literal>
        capacity <phrase role="std_section_label">[narytree.capacity]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">size_type</phrase> <phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Returns:</emphasis> The total number of child elements that the
          cursor <literal moreinfo="none">position</literal> can hold without requiring reallocation.
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Effects:</emphasis> A directive that informs an <literal moreinfo="none">nary_tree</literal>
          of a planned change in a given cursor's size, so that it can manage the
          storage allocation accordingly. After <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase></computeroutput>,
          <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">)</phrase></computeroutput>
          is greater or equal to the <literal moreinfo="none">size_type</literal> argument <literal moreinfo="none">n</literal>
          of reserve if reallocation happens; and equal to the previous value of
          <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">)</phrase></computeroutput>
          otherwise. Reallocation happens at this point if and only if the current
          capacity is less than the <literal moreinfo="none">size_type</literal> argument <literal moreinfo="none">n</literal>
          of <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">()</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Complexity:</emphasis> It does not change the size of the <literal moreinfo="none">nary_tree</literal>
          and takes at most linear time in <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Notes:</emphasis> Reallocation invalidates all the references,
          pointers, and cursors referring to the child elements of <literal moreinfo="none">position</literal>.
          It is guaranteed that no reallocation takes place during insertions to
          <literal moreinfo="none">position</literal> that happen after a call to <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">()</phrase></computeroutput> until the time when an insertion would
          make <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()</phrase></computeroutput>
          greater than the size specified in the most recent call to <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">()</phrase></computeroutput>.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.narytree.modifiers">
        <title><link linkend="tree.tree.narytree.modifiers"><literal moreinfo="none">nary_tree</literal>
        modifiers <phrase role="std_section_label">[narytree.modifiers]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
<phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Notes:</emphasis> Does not affect the validity of cursors and
          references.
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Notes:</emphasis> Invalidates only the cursors and references
          to the erased elements.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.narytree.special">
        <title><link linkend="tree.tree.narytree.special"><literal moreinfo="none">nary_tree</literal>
        specialized algorithms <phrase role="std_section_label">[narytree.special]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
              <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Effects:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">);</phrase></computeroutput>
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">inorder_first</phrase><phrase role="special">())</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Complexity:</emphasis> constant
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification"><para>
          <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">inorder_cfirst</phrase><phrase role="special">())</phrase></computeroutput>.
        </para>
        </simplesect>
      </section>
    </section>
    <section id="tree.tree.adaptors">
      <title><link linkend="tree.tree.adaptors">Hierarchy adaptors <phrase role="std_section_label">[hierarchy.adaptors]</phrase></link></title>
      <section id="tree.tree.adaptors.general">
        <title><link linkend="tree.tree.adaptors.general">In general <phrase role="std_section_label">[hiearchy.adaptors.general]</phrase></link></title>
        <para>
          Hierarchy adaptors each take a Hierarchy template parameter, and each of
          their constructors takes a Hierarchy reference argument. This hierarchy
          is copied into the Hierarchy member of each adapter. Most hierarchy adaptors
          satisfy most of the hierarchy requirements (except for anything that deals
          with allocators, as storage management is done by the adaptees). The exception
          is the group of balancing hierarchy adaptors ([hierarchy.balance]), whose
          members satisfy most of the requirements of a container, of a sequence
          and most of the optional sequence requirements instead (again except for
          anything allocation related, and some other exceptions).
        </para>
      </section>
      <section id="tree.tree.adaptors.foresttree">
        <title><link linkend="tree.tree.adaptors.foresttree">Template class <literal moreinfo="none">forest_tree</literal>
        <phrase role="std_section_label">[foresttree]</phrase></link></title> <simplesect role="std_definition">
        <para>
          A <literal moreinfo="none">forest_tree</literal> is a kind of mutable plain hierarchy that
          is instantiated with a mutable multiway hierarchy that has insertion semantics
          as a <literal moreinfo="none">binary_tree</literal> ([bintree.modifiers], §1)), and whose
          cursor types <literal moreinfo="none">cursor</literal> and <literal moreinfo="none">const_cursor</literal>
          satisfy a <literal moreinfo="none">binary_tree</literal>'s <literal moreinfo="none">cursor</literal> and
          <literal moreinfo="none">const_cursor</literal> type requirements ([bintree.types], §1-2)).
        </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">class</phrase> <phrase role="identifier">forest_tree</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Hierarchy</phrase>                                     <phrase role="identifier">hierarchy_type</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
    <phrase role="identifier">hierarchy_type</phrase> <phrase role="identifier">h</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="comment">// types:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">T</phrase>                                             <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">pointer</phrase>              <phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_pointer</phrase>        <phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">reference</phrase>            <phrase role="identifier">reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_reference</phrase>      <phrase role="identifier">const_reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">size_type</phrase>            <phrase role="identifier">size_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">difference_type</phrase>      <phrase role="identifier">difference_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">U</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">rebind</phrase> <phrase role="special">{</phrase>
      <phrase role="keyword">typedef</phrase> <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">U</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="keyword">template</phrase> <phrase role="identifier">rebind</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">other</phrase> <phrase role="special">&gt;</phrase>
        <phrase role="identifier">other</phrase><phrase role="special">;</phrase>
    <phrase role="special">};</phrase>

    <phrase role="comment">// construct/copy/destroy:</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">forest_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">forest_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">forest_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase>
      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>

    <phrase role="comment">// cursors:</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">root</phrase><phrase role="special">()</phrase>    <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">root</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">croot</phrase><phrase role="special">()</phrase>   <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">croot</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// capacity:</phrase>
    <phrase role="keyword">bool</phrase>      <phrase role="identifier">empty</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">empty</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase>  <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">max_size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// modifiers:</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
  <phrase role="special">};</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="comment">// specialized algorithms:</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
        </simplesect>
<section id="tree.tree.adaptors.foresttree.types">
          <title><link linkend="tree.tree.adaptors.foresttree.types"><literal moreinfo="none">forest_tree</literal>
          types <phrase role="std_section_label">[foresttree.types]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Notes:</emphasis> If (the adaptee) <literal moreinfo="none">Hierarchy</literal>'s
            cursor types are at least ascending bidirectional cursors, both <literal moreinfo="none">cursor</literal>
            and <literal moreinfo="none">const_cursor</literal> are ascending bidirectional cursors.
            Otherwise, they are descending forward cursors. The adaptee binary tree
            is "tilted" to yield an n-ary tree, meaning that the operational
            semantics of the adaptor cursor are as follows in terms of the adaptee
            cursor (only valid if present in the adaptor cursor's category; only
            given for mutable versions of expressions, const ones as according; expressions
            missing from the list mean operational semantics and complexity are for
            <literal moreinfo="none">b</literal> as they are for <literal moreinfo="none">f</literal>):
          </para>
          <table frame="all" id="tree.tree.adaptors.foresttree.types.table6">
            <title>forest_tree/binary tree cursor operational semantics correspondences</title>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>
                    <para>
                      adaptor cursor <literal moreinfo="none">f</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      adaptee cursor <literal moreinfo="none">b</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      complexity
                    </para>
                  </entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">f</phrase> <phrase role="special">=</phrase>
                      <phrase role="identifier">f</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">()</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">while</phrase> <phrase role="special">(!</phrase><phrase role="identifier">b</phrase><phrase role="special">.</phrase><phrase role="identifier">empty</phrase><phrase role="special">())</phrase>
                      <phrase role="identifier">b</phrase> <phrase role="special">=</phrase>
                      <phrase role="identifier">b</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">();</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      linear
                    </para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">++</phrase><phrase role="identifier">f</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">b</phrase> <phrase role="special">=</phrase>
                      <phrase role="special">(++</phrase><phrase role="identifier">b</phrase><phrase role="special">).</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      constant
                    </para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">--</phrase><phrase role="identifier">f</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">b</phrase> <phrase role="special">=</phrase>
                      <phrase role="special">--</phrase><phrase role="identifier">b</phrase><phrase role="special">.</phrase><phrase role="identifier">parent</phrase><phrase role="special">();</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      as <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">b</phrase><phrase role="special">.</phrase><phrase role="identifier">parent</phrase><phrase role="special">()</phrase></computeroutput>
                    </para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">!</phrase><phrase role="identifier">f</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">while</phrase> <phrase role="special">((!</phrase><phrase role="identifier">b</phrase><phrase role="special">).</phrase><phrase role="identifier">parity</phrase><phrase role="special">()</phrase>
                      <phrase role="special">==</phrase> <phrase role="number">1</phrase><phrase role="special">);</phrase> <phrase role="identifier">b</phrase>
                      <phrase role="special">=</phrase> <phrase role="special">(!</phrase><phrase role="identifier">b</phrase><phrase role="special">).</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      linear
                    </para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.foresttree.cons">
          <title><link linkend="tree.tree.adaptors.foresttree.cons"><literal moreinfo="none">forest_tree</literal>
          constructors, copy, and assignment <phrase role="std_section_label">[foresttree.cons]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">explicit</phrase> <phrase role="identifier">forest_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">forest_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
<phrase role="identifier">forest_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Complexity:</emphasis> The constructor <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase>
            <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase>
            <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
            <phrase role="identifier">vector</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">)</phrase></computeroutput> makes only <literal moreinfo="none">N</literal> calls
            to the copy constructor of <literal moreinfo="none">T</literal> (where <literal moreinfo="none">N</literal>
            is the number of elements in <literal moreinfo="none">subtree</literal>) and no reallocations
            if the cursor <literal moreinfo="none">subtree</literal> is of (either descending or
            ascending) forward, bidirectional, or random access categories. It does
            at most <literal moreinfo="none">2N</literal> calls to the copy constructor of <literal moreinfo="none">T</literal>
            and <literal moreinfo="none">logN</literal> reallocations if they are just cursors, since
            it is impossible to determine the size of <literal moreinfo="none">subtree</literal>
            and then do copying.
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Effects:</emphasis>
          </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase> <phrase role="identifier">i</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">root</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase> <phrase role="special">*</phrase><phrase role="identifier">i</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.foresttree.cursors">
          <title><link linkend="tree.tree.adaptors.foresttree.cursors"><literal moreinfo="none">forest_tree</literal>
          cursors <phrase role="std_section_label">[foresttree.cursors]</phrase></link></title>
        </section>
        <section id="tree.tree.adaptors.foresttree.modifiers">
          <title><link linkend="tree.tree.adaptors.foresttree.modifiers"><literal moreinfo="none">forest_tree</literal>
          modifiers <phrase role="std_section_label">[foresttree.modifiers]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
<phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Notes:</emphasis> Does not affect the validity of cursors and
            references.
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Notes:</emphasis> Invalidates only the cursors and references
            to the erased elements.
          </para>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.foresttree.special">
          <title><link linkend="tree.tree.adaptors.foresttree.special"><literal moreinfo="none">forest_tree</literal>
          specialized algorithms <phrase role="std_section_label">[foresttree.special]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
            <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Effects:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">);</phrase></computeroutput>
          </para>
          </simplesect>
        </section>
      </section>
      <section id="tree.tree.adaptors.multiwaytree">
        <title><link linkend="tree.tree.adaptors.multiwaytree">Class template <literal moreinfo="none">multiway_tree</literal>
        <phrase role="std_section_label">[multiwaytree]</phrase></link></title>
        <para>
          A <literal moreinfo="none">multiway_tree</literal> is a kind of mutable multiway hierarchy
          that is instantiated with a mutable plain hierarchy whose value type in
          turn is a container holding elements of <literal moreinfo="none">multiway_tree</literal>'s
          <literal moreinfo="none">value_type</literal>.
        </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">class</phrase> <phrase role="identifier">multiway_tree</phrase>
  <phrase role="special">{</phrase>
  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Hierarchy</phrase>                                     <phrase role="identifier">hierarchy_type</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
    <phrase role="identifier">hierarchy_type</phrase> <phrase role="identifier">h</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="comment">// types:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">T</phrase>                                             <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">pointer</phrase>              <phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_pointer</phrase>        <phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">reference</phrase>            <phrase role="identifier">reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_reference</phrase>      <phrase role="identifier">const_reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">size_type</phrase>            <phrase role="identifier">size_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">difference_type</phrase>      <phrase role="identifier">difference_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">U</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">rebind</phrase> <phrase role="special">{</phrase>
      <phrase role="keyword">typedef</phrase> <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">U</phrase><phrase role="special">,</phrase>
        <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="keyword">template</phrase> <phrase role="identifier">rebind</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase> <phrase role="special">&gt;::</phrase><phrase role="identifier">other</phrase> <phrase role="special">&gt;</phrase>
          <phrase role="identifier">other</phrase><phrase role="special">;</phrase>
    <phrase role="special">};</phrase>

    <phrase role="comment">// construct/copy/destroy:</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">multiway_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">multiway_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">multiway_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="special">~</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase>
      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>

    <phrase role="comment">// cursors:</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">root</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">croot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase> <phrase role="keyword">const</phrase><phrase role="special">();</phrase>

    <phrase role="comment">// capacity:</phrase>
    <phrase role="keyword">bool</phrase>      <phrase role="identifier">empty</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">max_size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>

    <phrase role="comment">// modifiers:</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">rotate</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">p</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
  <phrase role="special">};</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="comment">// specialized algorithms:</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
        <para>
          Types <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase></computeroutput>
          and <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase></computeroutput>
          are required to be random access cursors.
        </para>
        <section id="tree.tree.adaptors.multiwaytree.types">
          <title><link linkend="tree.tree.adaptors.multiwaytree.types"><literal moreinfo="none">multiway_tree</literal>
          types <phrase role="std_section_label">[multiwaytree.types]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            Both <literal moreinfo="none">cursor</literal> and <literal moreinfo="none">const_cursor</literal> have
            to fulfill the plain cursor requirements ([cursor.flavors]). If <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase></computeroutput>
            is an ascending random access cursor, <literal moreinfo="none">cursor</literal> and
            <literal moreinfo="none">const_cursor</literal> are also ascending random access cursors
            ([ascending.random.access.cursors]); otherwise, they are descending random
            access cursor ([descending.random.access.cursors]).
          </para>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Notes:</emphasis> The operational semantics of the adaptor
            cursor are as follows in terms of the adaptee cursor (only valid if present
            in the adaptor cursor's category; only given for mutable versions of
            expressions, const ones as according; expressions missing from the list
            mean operational semantics and complexity are for <literal moreinfo="none">m</literal>
            as they are for <literal moreinfo="none">n</literal>):
          </para>
          <table frame="all" id="tree.tree.adaptors.multiwaytree.types.table7">
            <title>Multiway/nary tree cursor operational semantics correspondences</title>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>
                    <para>
                      adaptor cursor <literal moreinfo="none">m</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      adaptee cursor <literal moreinfo="none">n</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      complexity
                    </para>
                  </entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*</phrase><phrase role="identifier">m</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*((</phrase><phrase role="identifier">p</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[</phrase><phrase role="identifier">b</phrase><phrase role="special">.</phrase><phrase role="identifier">parity</phrase><phrase role="special">()])</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      constant
                    </para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.multiwaytree.cons">
          <title><link linkend="tree.tree.adaptors.multiwaytree.cons"><literal moreinfo="none">multiway_tree</literal>
          constructors, copy, and assignment <phrase role="std_section_label">[multiwaytree.cons]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">explicit</phrase> <phrase role="identifier">multiway_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">multiway_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
<phrase role="identifier">multiway_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Complexity:</emphasis> The constructor <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase>
            <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase>
            <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
            <phrase role="identifier">vector</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">)</phrase></computeroutput> makes only <literal moreinfo="none">N</literal> calls
            to the copy constructor of <literal moreinfo="none">T</literal> (where <literal moreinfo="none">N</literal>
            is the number of elements in <literal moreinfo="none">subtree</literal>) and no reallocations
            if the cursor <literal moreinfo="none">subtree</literal> is of (either descending or
            ascending) forward, bidirectional, or random access categories. It does
            at most <literal moreinfo="none">2N</literal> calls to the copy constructor of <literal moreinfo="none">T</literal>
            and <literal moreinfo="none">logN</literal> reallocations if they are just cursors, since
            it is impossible to determine the size of <literal moreinfo="none">subtree</literal>
            and then do copying.
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Effects:</emphasis>
          </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase> <phrase role="identifier">i</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">root</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase> <phrase role="special">*</phrase><phrase role="identifier">i</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.multiwaytree.cursors">
          <title><link linkend="tree.tree.adaptors.multiwaytree.cursors"><literal moreinfo="none">multiway_tree</literal>
          cursors <phrase role="std_section_label">[multiwaytree.cursors]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Complexity:</emphasis> constant
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">();</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Returns:</emphasis> A cursor to the <literal moreinfo="none">multiway_tree</literal>'s
            first element in inorder (see [order.iterators], §4).
          </para>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Complexity:</emphasis> constant.
          </para>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.multiwaytree.capacity">
          <title><link linkend="tree.tree.adaptors.multiwaytree.capacity"><literal moreinfo="none">multiway_tree</literal>
          capacity <phrase role="std_section_label">[multiwaytree.capacity]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">size_type</phrase> <phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Returns:</emphasis> The total number of child elements that
            the cursor <literal moreinfo="none">position</literal> can hold without requiring reallocation.
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Effects:</emphasis> A directive that informs an <literal moreinfo="none">multiway_tree</literal>
            of a planned change in a given cursor's size, so that it can manage the
            storage allocation accordingly. After <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase></computeroutput>, <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">)</phrase></computeroutput> is greater or equal to the <literal moreinfo="none">size_type</literal>
            argument <literal moreinfo="none">n</literal> of reserve if reallocation happens; and
            equal to the previous value of <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">)</phrase></computeroutput> otherwise. Reallocation happens at this
            point if and only if the current capacity is less than the <literal moreinfo="none">size_type</literal>
            argument <literal moreinfo="none">n</literal> of <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">()</phrase></computeroutput>.
          </para>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Complexity:</emphasis> It does not change the size of the
            <literal moreinfo="none">multiway_tree</literal> and takes at most linear time in <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()</phrase></computeroutput>.
          </para>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Notes:</emphasis> Reallocation invalidates all the references,
            pointers, and cursors referring to the child elements of <literal moreinfo="none">position</literal>.
            It is guaranteed that no reallocation takes place during insertions to
            <literal moreinfo="none">position</literal> that happen after a call to <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">()</phrase></computeroutput>
            until the time when an insertion would make <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()</phrase></computeroutput> greater than the size specified in
            the most recent call to <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">()</phrase></computeroutput>.
          </para>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.multiwaytree.modifiers">
          <title><link linkend="tree.tree.adaptors.multiwaytree.modifiers"><literal moreinfo="none">multiway_tree</literal>
          modifiers <phrase role="std_section_label">[multiwaytree.modifiers]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
<phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Notes:</emphasis> Does not affect the validity of cursors and
            references.
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Notes:</emphasis> Invalidates only the cursors and references
            to the erased elements.
          </para>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.multiwaytree.special">
          <title><link linkend="tree.tree.adaptors.multiwaytree.special"><literal moreinfo="none">multiway_tree</literal>
          specialized algorithms <phrase role="std_section_label">[multiwaytree.special]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
              <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Effects:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">);</phrase></computeroutput>
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">inorder_first</phrase><phrase role="special">())</phrase></computeroutput>.
          </para>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Complexity:</emphasis> constant
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">inorder_cfirst</phrase><phrase role="special">())</phrase></computeroutput>.
          </para>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Complexity:</emphasis> constant
          </para>
          </simplesect>
        </section>
      </section>
      <section id="tree.tree.adaptors.augment">
        <title><link linkend="tree.tree.adaptors.augment">Augmenting hierarchy adaptors
        <phrase role="std_section_label">[hierarchy.augment]</phrase></link></title>
        <para>
          An augmenting hierarchy "augments" a mutable multiway hierarchy
          which it is given as a template parameter by associating additional information
          with its elements and modeling a mutable multiway hierarchy in turn. This
          additional information is not directly exposed, but only readable via certain
          member functions of the augmentor; it is updated internally in order to
          adapt to structural or content-wise changes in the hierarchy. The library
          provides one augmenting hierarchy adaptor template class: <literal moreinfo="none">rank_tree</literal>,
          found in header <literal moreinfo="none">&lt;augment&gt;</literal>.
        </para>
        <section id="tree.tree.adaptors.augment.ranktree">
          <title><link linkend="tree.tree.adaptors.augment.ranktree">Class template
          <literal moreinfo="none">rank_tree</literal> <phrase role="std_section_label">[ranktree]</phrase></link></title>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">class</phrase> <phrase role="identifier">rank_tree</phrase>
  <phrase role="special">{</phrase>
  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Hierarchy</phrase>                                     <phrase role="identifier">hierarchy_type</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
    <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="keyword">template</phrase> <phrase role="identifier">rebind</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase><phrase role="identifier">size_t</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;::</phrase><phrase role="identifier">other</phrase> <phrase role="identifier">h</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="comment">// types:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">T</phrase>                                             <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">pointer</phrase>              <phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_pointer</phrase>        <phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">reference</phrase>            <phrase role="identifier">reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_reference</phrase>      <phrase role="identifier">const_reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">size_type</phrase>            <phrase role="identifier">size_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">difference_type</phrase>      <phrase role="identifier">difference_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">U</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">rebind</phrase> <phrase role="special">{</phrase>
      <phrase role="keyword">typedef</phrase> <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">U</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="keyword">template</phrase> <phrase role="identifier">rebind</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">other</phrase> <phrase role="special">&gt;</phrase>
        <phrase role="identifier">other</phrase><phrase role="special">;</phrase>
    <phrase role="special">};</phrase>

    <phrase role="comment">// construct/copy/destroy:</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">rank_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">rank_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">rank_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="special">~</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase>
      <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>

    <phrase role="comment">// cursors:</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">root</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">croot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase> <phrase role="keyword">const</phrase><phrase role="special">();</phrase>

    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">rank</phrase><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">rank</phrase><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// capacity:</phrase>
    <phrase role="keyword">bool</phrase>      <phrase role="identifier">empty</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">max_size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>

    <phrase role="comment">// modifiers:</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">rotate</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
  <phrase role="special">};</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hier</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="comment">// specialized algorithms:</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
          <para>
            Each function listed in the public interface of <literal moreinfo="none">rank_tree</literal>
            as above calls a function of the same name for its adaptee object <literal moreinfo="none">h</literal>,
            plus possibly other operations with guaranteed logarithmic time complexity
            in total. This means that operational semantics and time complexities
            are as specified by the <literal moreinfo="none">hierarchy_type</literal>; and that a
            function can only be called if a function of the same name is present
            in the public interface of <literal moreinfo="none">hierarchy_type</literal>. (The only
            exception to the above stated are the functions <literal moreinfo="none">rank()</literal>,
            which are newly introduced.)
          </para>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">rank</phrase><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">rank</phrase><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Returns:</emphasis> A cursor (or <literal moreinfo="none">const_cursor</literal>)
            to the <literal moreinfo="none">n=th element of the hierarchy in inorder, counting from
            =inorder_first()</literal>.
          </para>
          </simplesect> <simplesect role="std_specification"><para>
            <emphasis>Complexity:</emphasis> logarithmic in <literal moreinfo="none">size()</literal>.
          </para>
          </simplesect>
        </section>
      </section>
      <section id="tree.tree.adaptors.balance">
        <title><link linkend="tree.tree.adaptors.balance">Balancing hierarchy adaptors
        <phrase role="std_section_label">[tr.hierarchy.balance]</phrase></link></title>
        <section id="tree.tree.adaptors.balance.cons">
          <title><link linkend="tree.tree.adaptors.balance.cons">Balancing adaptor
          constructors, copy, and assigment <phrase role="std_section_label">[tr.hierarchy.balance.cons]</phrase></link></title>
        </section>
        <section id="tree.tree.adaptors.balance.map">
          <title><link linkend="tree.tree.adaptors.balance.map">Balancing adaptor
          map operations <phrase role="std_section_label">[tr.hierarchy.balance.map]</phrase></link></title>
        </section>
        <section id="tree.tree.adaptors.balance.modifiers">
          <title><link linkend="tree.tree.adaptors.balance.modifiers">Balancing adaptor
          modifiers <phrase role="std_section_label">[tr.hierarchy.balance.modifiers]</phrase></link></title>
        </section>
        <section id="tree.tree.adaptors.balance.special">
          <title><link linkend="tree.tree.adaptors.balance.special">Balancing adaptor
          specialized algorithms <phrase role="std_section_label">[tr.hierarchy.balance.special]</phrase></link></title>
        </section>
      </section>
    </section>
  </section>
  </section> </section> <section role="std_section" id="tree.proposal.iterators" label="24" label-style="no-parent">
<title><link linkend="tree.proposal.iterators">Iterators library
  <phrase role="std_section_label">[iterators]</phrase></link></title> </section> <section role="std_section" id="tree.proposal.algorithms" label="25" label-style="no-parent">
<title><link linkend="tree.proposal.algorithms">Algorithms
  library <phrase role="std_section_label">[algorithms]</phrase></link></title> </section> </section>

  <section id="tree.references">
    <title><link linkend="tree.references">References</link></title>
    <variablelist>
      <title>References</title>
      <varlistentry>
        <term>austern</term>
        <listitem>
          <para>
            Austern, Matthew H.; Stroustrup, Bjarne; Thorup, Mikkel; Wilikinson,
            John. <emphasis>Untangling the Balancing and Searching of Balanced Binary
            Search Trees</emphasis>, Software: Practice and Experience 33(13): 1273-1298
            (2003) Electronic Appendix: http://www.research.att.com/~bs/tree-appendix.pdf
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>cormen</term>
        <listitem>
          <para>
            Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford.
            <emphasis>Introduction to Algorithms</emphasis>. Second Edition (MIT
            Press, 2001)
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>dreizin</term>
        <listitem>
          <para>
            Dreizin, Vladimir; Kosnik, Benjamin; Tavory, Ami. <emphasis>Policy-Based
            Data Structures</emphasis>, http://gcc.gnu.org/onlinedocs/libstdc++<emphasis>ext/pb_ds</emphasis>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>ekman</term>
        <listitem>
          <para>
            Ekman, Rasmus. <emphasis>Structured Associative Containers</emphasis>,
            http://www.abc.se/~re/code/tst
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>gottschlich</term>
        <listitem>
          <para>
            Gottschlich, Justin. <emphasis>C++ Trees</emphasis>, http://www.gamedev.net/reference/articles/article2192.asp
            and http://www.gamedev.net/reference/articles/article2233.asp
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>haas</term>
        <listitem>
          <para>
            Haas, Mitchell. <emphasis>Tree Container Library</emphasis>, http://www.datasoftsolutions.net/tree_container_library/overview.php
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>karas</term>
        <listitem>
          <para>
            Karas, Walt. <emphasis>C++ AVL Tree Template</emphasis>, http://us.geocities.com/wkaras/gen_cpp/avl_tree.html
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>knuth97</term>
        <listitem>
          <para>
            Knuth, Donald E. <emphasis>The Art of Computer Programming</emphasis>.
            Volume 1: Fundamental Algorithms. Third Edition (Reading, Massachusetts:
            Addison-Wesley, 1997)
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>knuth98</term>
        <listitem>
          <para>
            Knuth, Donald E. <emphasis>The Art of Computer Programming</emphasis>.
            Volume 3: Sorting and Searching. Second Edition (Reading, Massachusetts:
            Addison-Wesley, 1998)
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>mirwaisi</term>
        <listitem>
          <para>
            Mirwaisi, Jeff. <emphasis>treelib</emphasis>, https://boost-consulting.com:8443/trac/soc/attachment/wiki/tree/resources/trees/treelib.tar.bz2
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>parent</term>
        <listitem>
          <para>
            Parent, Sean et al. <emphasis>forest</emphasis>, http://opensource.adobe.com/group__forest__related.html
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>peeters</term>
        <listitem>
          <para>
            Peeters, Kasper. <emphasis>tree.hh: an STL-like C++ tree class</emphasis>,
            http://www.aei.mpg.de/~peekas/tree/
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>rivera</term>
        <listitem>
          <para>
            Rivera, René. <emphasis>RankTree.h</emphasis>, http://redshift-software.com/~grafik/RankTree.h
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
</article>
