<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="tree" rev:last-revision="$Date: 2013/06/06 14:01:32 $">
  <title>Hierarchical Data Structures and Related Concepts for the C++ Standard Library</title>
  <articleinfo>
    <authorgroup>
    <author>
      <firstname>Bernhard</firstname> <surname>Reiter</surname>
    </author>
    <author>
      <firstname>René</firstname> <surname>Rivera</surname>
    </author>
    </authorgroup>
    <copyright>
      <year>2006</year> <year>2007</year> <year>2008</year> <year>2009</year> <holder>Bernhard
      Reiter</holder>
    </copyright>
    <copyright>
      <year>2006</year> <year>2007</year> <year>2008</year> <year>2009</year> <year>2010</year>
      <year>2011</year> <year>2012</year> <year>2013</year> <holder>René Rivera</holder>
    </copyright>
    <legalnotice id="tree.legal">
      <para>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
      </para>
    </legalnotice>
    <articlepurpose>
      Hierarchical Data Structures and Related Concepts for the C++ Standard Library
    </articlepurpose>
  </articleinfo>
  <section id="tree.preamble">
    <title><link linkend="tree.preamble">Hierarchical Data Structures and Related
    Concepts for the C++ Standard Library</link></title>
    <para>
      <emphasis role="bold">Bernhard Reiter and René Rivera</emphasis>
    </para>
    <simplesect role="std_doc_info">
    <variablelist>
      <title/>
      <varlistentry>
        <term>Document No.</term>
        <listitem>
          <para>
            WG21/D????=J16/??-????
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Supercedes</term>
        <listitem>
          <para>
            WG21/N2101=J16/06-0171
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Date</term>
        <listitem>
          <para>
            2013-Jun-06
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Project</term>
        <listitem>
          <para>
            Programming Language C++
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Reply to</term>
        <listitem>
          <para>
            René Rivera &lt;<ulink url="mailto:rrivera@acm.org">rrivera@acm.org</ulink>&gt;
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    </simplesect>
<section id="tree.preamble.introduction">
      <title><link linkend="tree.preamble.introduction">Introduction</link></title>
      <para>
        This paper proposes the addition of library components covering tree structures
        and related concepts to Programming Languages -- C++. The proposal is based
        on work towards a Boost Tree component library.
      </para>
      <para>
        The library strives to cover many of the relevant aspects within the vast
        field linked to the notion of trees in computer science.
      </para>
    </section>
    <section id="tree.preamble.motivation_and_scope">
      <title><link linkend="tree.preamble.motivation_and_scope">Motivation and Scope</link></title>
      <section id="tree.preamble.motivation_and_scope.why_is_this_important">
        <title><link linkend="tree.preamble.motivation_and_scope.why_is_this_important">Why
        is this important?</link></title>
        <para>
          This proposal is motivated by the wish to establish methods of dealing
          with hierarchical data structures in a manner that is similar to that of
          the Standard Template Library (STL) for linear ones. That is, it seeks
          to provide clear, straight-forward, versatile and comprehensive concepts,
          data structures and algorithms for trees and related structures that allow
          efficient implementation while not exposing implementation details.
        </para>
        <para>
          In particular, this proposal strives to unite types of hierarchical data
          structures that have historically been treated separately, although there
          is arguably good reason to view their role for algorithms as different
          aspects of common underlying concepts. Formally, this proposal's desired
          scope is covering all <emphasis>rooted ordered connected acyclic graphs</emphasis>.
        </para>
      </section>
      <section id="tree.preamble.motivation_and_scope.what_kinds_of_problems_does_it_a">
        <title><link linkend="tree.preamble.motivation_and_scope.what_kinds_of_problems_does_it_a">What
        kinds of problems does it address, and what kinds of programmers is it intended
        to support?</link></title>
        <para>
          Existing tree implementations as listed in the References section as well
          as the number of posts on C++ related newsgroups give an evidence of very
          general, high interest in tree and related data structures. Formalization
          of how to deal with hierarchical data structures seems to be relevant as
          programmers of any level of skill working in any given field is likely
          to need such a structure at one point.
        </para>
      </section>
      <section id="tree.preamble.motivation_and_scope.is_it_based_on_existing_practice">
        <title><link linkend="tree.preamble.motivation_and_scope.is_it_based_on_existing_practice">Is
        it based on existing practice?</link></title>
        <para>
          No; this proposal originates in an effort to create a generic tree container
          component for <ulink url="http://www.boost.org">Boost</ulink> in the course
          of <ulink url="https://developers.google.com/open-source/soc/2006/#boost">Google
          Summer of Code™ 2006</ulink>, so at the time of this writing, implementation
          work is still unfinished and, however inspired by and striving to avoid
          past issues and such ones arising from current implementation efforts (see
          below) it is, it has not been used in practice yet.
        </para>
      </section>
      <section id="tree.preamble.motivation_and_scope.is_there_a_reference_implementat">
        <title><link linkend="tree.preamble.motivation_and_scope.is_there_a_reference_implementat">Is
        there a reference implementation?</link></title>
        <para>
          Yes; the current state is available from <ulink url="https://github.com/grafikrobot/boost-tree">https://github.com/grafikrobot/boost-tree</ulink>.
        </para>
      </section>
    </section>
    <section id="tree.preamble.impact_on_the_standard">
      <title><link linkend="tree.preamble.impact_on_the_standard">Impact on the Standard</link></title>
      <section id="tree.preamble.impact_on_the_standard.what_does_it_depend_on_and_what_">
        <title><link linkend="tree.preamble.impact_on_the_standard.what_does_it_depend_on_and_what_">What
        does it depend on, and what depends on it?</link></title>
        <para>
          It depends on some standard library components, such as <literal moreinfo="none">std::allocator</literal>
          which is used as the default allocator template argument at some points.
          Concepts like allocators or iterators are reused and in some cases adapted.
        </para>
      </section>
      <section id="tree.preamble.impact_on_the_standard.is_it_a_pure_extension_or_does_i">
        <title><link linkend="tree.preamble.impact_on_the_standard.is_it_a_pure_extension_or_does_i">Is
        it a pure extension, or does it require changes to standard components?</link></title>
        <para>
          Most of the proposed library is a pure extension.
        </para>
        <para>
          Some extensions to <literal moreinfo="none">&lt;algorithm&gt;</literal> and to <literal moreinfo="none">&lt;iterator&gt;</literal>
          are proposed.
        </para>
        <para>
          Additionally, while not proposed herein, it has sometimes been suggested
          to add a template parameter to the STL associative containers <literal moreinfo="none">set</literal>,
          <literal moreinfo="none">multiset</literal>, <literal moreinfo="none">map</literal>, and <literal moreinfo="none">multimap</literal>
          (and possibly an argument to their constructors) specifying a policy for
          storing elements, or, more concretely, what tree. The balancers presented
          in this proposal would lend themselves to such use. Indicating what type
          of balanced hierarchy to use for associative containers would create some
          amount of symmetry to <literal moreinfo="none">unordered</literal> containers that allow
          specification of a hash functor; it is however a momentous decision in
          which position to put such a parameter. The same position as for <literal moreinfo="none">unordered</literal>
          containers (before the comparison functor) would require changes in existing
          code; making it the last parameter (after the allocator) would allow existing
          code to remain unchanged, but seems somewhat irritating when compared to
          <literal moreinfo="none">unordered</literal> containers.
        </para>
      </section>
      <section id="tree.preamble.impact_on_the_standard.can_it_be_implemented_using_toda">
        <title><link linkend="tree.preamble.impact_on_the_standard.can_it_be_implemented_using_toda">Can
        it be implemented using today's compilers, or does it require language features
        that will only be available as part of C++11</link></title>
        <para>
          It can be, and partly has been, implemented with today's compilers.
        </para>
        <para>
          Note that it might be worthwhile to investigate if the present Container
          concept should be modified so that it only covers the requirements as of
          paragraph 2 of section <ulink url="#hierarchy.req">[hierarchy.req]</ulink>
          of this proposal, which correspond to the current Container concept with
          the exception of any expressions that implicitly assume linear internal
          structure and outsource those to a "Linear Container" concept
          as similarly formalized in the <ulink url="http://boost.org/libs/range/doc/range.html">Boost
          Range concept</ulink> (<ulink url="http://boost.org/libs/range/doc/range.html">http://boost.org/libs/range/doc/range.html</ulink>)
          externally to the Standard.
        </para>
      </section>
    </section>
    <section id="tree.preamble.important_design_decisions">
      <title><link linkend="tree.preamble.important_design_decisions">Important Design
      Decisions</link></title>
      <section id="tree.preamble.important_design_decisions.why_did_you_choose_the_specific_">
        <title><link linkend="tree.preamble.important_design_decisions.why_did_you_choose_the_specific_">Why
        did you choose the specific design that you did?</link></title>
        <para>
          One of the most important assets of the present design is the cursor concept
          as a hierarchical continuation to the STL's iterator concept, and the externally
          defined range concept. Among their benefits, cursors allow to handle both
          client data access, by dereference, and subtree access while hiding the
          normally underlying node structure and providing a uniform interface to
          algorithms that are thus enabled to deal with a number of different kinds
          of trees. On the other hand, this abstraction achieves independence of
          implementation details, such as nodes for storage in many cases, allowing
          the underlying concepts to be applicable to other possible implementations
          as well.
        </para>
      </section>
      <section id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid">
        <title><link linkend="tree.preamble.important_design_decisions.what_alternatives_did_you_consid">What
        alternatives did you consider, and what are the tradeoffs?</link></title>
        <bridgehead renderas="sect5" id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.h0">
          <phrase id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.trees_of_trees"/><link linkend="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.trees_of_trees">Trees
          of trees</link>
        </bridgehead>
        <para>
          Trees, being recursively defined data structures, seem to somewhat lend
          themselves to recursive implementation, i.e. declaring them in a way so
          they consist of a client value part and a certain number of trees in turn
          (as e.g. in case of <link linkend="haas">[haas]</link>). Such an approach
          would allow for uniform treatment of the subtrees, but would duplicate
          allocators and imply structure that need not be present. The tree, like
          existing STL containers, should be responsible for data representation
          and storage.
        </para>
        <bridgehead renderas="sect5" id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.h1">
          <phrase id="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.augmentors_balancers_as_policies"/><link linkend="tree.preamble.important_design_decisions.what_alternatives_did_you_consid.augmentors_balancers_as_policies">Augmentors/balancers
          as policies</link>
        </bridgehead>
        <para>
          Inspired by <link linkend="austern">[austern]</link> and <link linkend="dreizin">[dreizin]</link>,
          the original approach undertaken when working on the reference implementation
          was to pass policy template arguments to template class <literal moreinfo="none">binary_tree</literal>.
          While reproducing the (otherwise unbalanced) tree/cursor interface seemed
          logical at first, it turned out that this was conceptually not entirely
          clean, as e.g. it preferred one type of linear order, namely inorder, over
          the others by putting such strong focus on inorder-invariant balancing
          and its possible applications; also, balancing and augmenting metadata
          would inevitably have been much more visible. It seemed more appropriate
          to have different balancing adaptors and augmenting adaptors that would
          replicate the interface to do that work.
        </para>
      </section>
      <section id="tree.preamble.important_design_decisions.what_are_the_consequences_of_you">
        <title><link linkend="tree.preamble.important_design_decisions.what_are_the_consequences_of_you">What
        are the consequences of your choices, for users and implementors?</link></title>
        <para>
          As focus was put on versatility and comprehensiveness, we hope users will
          find this a powerful framework that covers most important aspects of dealing
          with hierarchical data structures in a rather intuitive way, once they
          have adapted to the notion of cursors which, although being the interface
          relevant portion of the well-known node implementation of trees, partly
          diverge in their usage from plain node objects.
        </para>
        <para>
          Wherever reasonably possible, strong time complexity guarantees are given,
          which mostly, while trying not to require much space overhead, demand implementations
          that make use of any time and space saving techniques available (e.g. using
          arrays for both children of a binary tree node, see e.g. <link linkend="austern">[austern]</link>),
          which may partly restrict implementors to one "proper" way of
          doing things.
        </para>
      </section>
      <section id="tree.preamble.important_design_decisions.what_decisions_are_left_up_to_im">
        <title><link linkend="tree.preamble.important_design_decisions.what_decisions_are_left_up_to_im">What
        decisions are left up to implementors?</link></title>
        <para>
          Most of the requirements for the library components presented in this proposal
          are rather tightly formulated in order to allow for them being both efficient
          and general enough. It is however hoped that the conceptual abstraction
          of hierarchies and cursors may be of general use, also allowing for more
          specific implementations where required (although probably not as part
          of the library; ideally comparable to the role of containers and iterators
          in modern C++ code).
        </para>
      </section>
      <section id="tree.preamble.important_design_decisions.if_there_are_any_similar_librari">
        <title><link linkend="tree.preamble.important_design_decisions.if_there_are_any_similar_librari">If
        there are any similar libraries in use, how do their design decisions compare
        to yours?</link></title>
        <para>
          Trees, having attracted much attention in the C++ community, are found
          in various implementations and as subjects of a number of papers. Contrary
          to the present proposal, practically all of them deal either with trees
          as used for sorted associative containers (with logarithmic time complexity
          for more relevant operations, achieved by some sort of balancing; examples
          are <link linkend="dreizin">[dreizin]</link>, <link linkend="ekman">[ekman]</link>
          and <link linkend="karas">[karas]</link>; plus, most current STL implementations
          use a red-black tree as their associative containers' base) or with what
          we call "external" hierarchies in the following (whose structure
          is dictated e.g. by a file system directory tree, an XML file or an AST;
          see e.g. <link linkend="gottschlich">[gottschlich]</link>, <link linkend="haas">[haas]</link>,
          <link linkend="parent">[parent]</link> and <link linkend="peeters">[peeters]</link>),
          but rarely both fields of application.
        </para>
        <para>
          Approaches as found in <link linkend="austern">[austern]</link> or <link linkend="mirwaisi">[mirwaisi]</link> go some steps further and have provided
          valuable inspiration for this project, but still do not formalize anything
          similar as the cursor-based interface in this proposal for dealing with
          a tree's contents.
        </para>
        <para>
          The <ulink url="http://www.boost.org/libs/graph/">BGL</ulink>, finally,
          deals with graphs that are even more general than hierarchical ones, which
          does not allow them to profit from specific hierarchy properties as much
          as the ones presented in this proposal. Making cursors logical extensions
          of iterators would probably also have been more difficult with a BGL-based
          approach.
        </para>
      </section>
    </section>
    <section id="tree.preamble.future_directions">
      <title><link linkend="tree.preamble.future_directions">Future Directions</link></title>
      <para>
        While it is hoped that the current proposal somewhat reunites balanced binary
        trees, B-trees and "external" hierarchies, which should also facilitate
        work with some higher-level structures (e.g. n-ary trees to implement tries),
        some of those higher-level components might be an interesting feature to
        add to the library, such as patricia tries or ternary search tries.
      </para>
    </section>
  </section>
  <section role="std_proposal" id="tree.proposal">
<title><link linkend="tree.proposal">Proposed Text</link></title>
  <note>
    <para>
      Notes that are not part of the proposed text appear in gray boxes.
    </para>
  </note>
  <section role="std_section" id="tree.proposal.containers" label="23" label-style="no-parent">
<title><link linkend="tree.proposal.containers">Container library <phrase role="std_section_label">[containers]</phrase></link></title> <section role="std_section" id="tree.proposal.hierarchy" label="7">
<title><link linkend="tree.proposal.hierarchy">Hierarchy
  containers <phrase role="std_section_label">[hierarchy]</phrase></link></title>

  <section id="tree.req">
    <title><link linkend="tree.req">Hierarchy containers requirements <phrase role="std_section_label">[hierarchy.req]</phrase></link></title>
    <para>
      In this section's tables, <literal moreinfo="none">X</literal> denotes a hierarchy class,
      <literal moreinfo="none">a</literal> denotes a value of <literal moreinfo="none">X</literal> containing elements
      of type <literal moreinfo="none">T</literal>, <literal moreinfo="none">c</literal> denotes a valid, non-on-top
      cursor satisfying input cursor requirements, <literal moreinfo="none">p</literal> denotes a
      valid, non-on-top cursor to <literal moreinfo="none">a</literal>, <literal moreinfo="none">q</literal> denotes
      a valid, dereferenceable cursor to <literal moreinfo="none">a</literal>, <literal moreinfo="none">t</literal>
      denotes an lvalue or a const rvalue of <literal moreinfo="none">X::value_type</literal>, and
      <literal moreinfo="none">rv</literal> denotes a non-const rvalue of <literal moreinfo="none">X::value_type</literal>.
      <literal moreinfo="none">Args</literal> denotes a template parameter pack; <literal moreinfo="none">args</literal>
      denotes a function parameter pack with the pattern <literal moreinfo="none">Args&amp;&amp;</literal>.
    </para>
    <section id="tree.req.general">
      <title><link linkend="tree.req.general">General hierarchy requirements <phrase role="std_section_label">[hier.req.general]</phrase></link></title>
      <note>
        <para>
          Need better definitions for hierachy, plain hierarchy, and multiway hierarchy.
        </para>
      </note>
      <simplesect role="std_requisite">
      <para>
        A hierarchy is an object that stores a finite set of objects, all of the
        same type, in a hierarchical manner, i.e. as a rooted ordered connected acyclic
        graph. Hierarchies introduce a cursor concept for navigation instead of iterators.
        The library provides two kinds of native hierarchies: <literal moreinfo="none">binary_tree</literal>,
        and <literal moreinfo="none">nary_tree</literal>, along with hierarchy-yielding hierarchy
        adaptors <literal moreinfo="none">forest_tree</literal>, and <literal moreinfo="none">multiway_tree</literal>.
      </para>
      </simplesect> <simplesect role="std_requisite">
      <para>
        Hierarchy containers conform to the requirements of Containers ([container.requirements]),
        except that the expressions in Table 1 are not required to be valid, where
        <literal moreinfo="none">a</literal> and <literal moreinfo="none">b</literal> denote values of a type <literal moreinfo="none">X</literal>,
        and <literal moreinfo="none">X</literal> is a hierarchy container class:
      </para>
      <table frame="all" id="tree.req.general.table1">
        <title>Container requirements that are not required for hierarchy containers</title>
        <tgroup cols="1">
          <thead>
            <row>
              <entry>
                <para>
                  unsupported expression
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">X::iterator</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">X::const_iterator</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">X::difference_type</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.begin()</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.end()</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.cbegin()</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.cend()</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a == b</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a != b</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">X::reverse_iterator</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">X::const_reverse_iterator</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.rbegin()</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.rend()</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.crbegin()</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.crend()</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a &lt; b</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a &gt; b</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a &lt;= b</literal>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a &gt;= b</literal>
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      </simplesect><para>
        Non-constant complexity requirements in this clause are stated in one of
        a number of possible different ways: unless specified otherwise, they are
        expressed in terms of the number of operations <literal moreinfo="none">n</literal>, which
        stands for the total number of elements in the hierarchy; in some cases,
        however, they are stated in terms of another value.
      </para>
      <simplesect role="std_requisite">
      <table frame="all" id="tree.req.general.table2">
        <title>Hierarchy requirements (in addition to container)</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>
                <para>
                  expression
                </para>
              </entry>
              <entry>
                <para>
                  return type
                </para>
              </entry>
              <entry>
                <para>
                  assertion/note<sbr/> pre/post-condition
                </para>
              </entry>
              <entry>
                <para>
                  complexity
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">X::cursor</literal>
                </para>
              </entry>
              <entry>
                <para>
                  cursor type pointing to <literal moreinfo="none">T</literal>
                </para>
              </entry>
              <entry>
                <para>
                  any cursor category
                </para>
              </entry>
              <entry>
                <para>
                  compile time
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">X::const_cursor</literal>
                </para>
              </entry>
              <entry>
                <para>
                  cursor type pointing to <literal moreinfo="none">const T</literal>
                </para>
              </entry>
              <entry>
                <para>
                  any cursor category
                </para>
              </entry>
              <entry>
                <para>
                  compile time
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.root()</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">iterator</literal> for mutable <literal moreinfo="none">a</literal>;
                  <sbr/> <literal moreinfo="none">const_iterator</literal> for constant <literal moreinfo="none">a</literal>
                </para>
              </entry>
              <entry>
                <para>
                   
                </para>
              </entry>
              <entry>
                <para>
                  constant
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.croot()</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">const_iterator</literal>
                </para>
              </entry>
              <entry>
                <para>
                   
                </para>
              </entry>
              <entry>
                <para>
                  constant
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.shoot()</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">iterator</literal> for mutable <literal moreinfo="none">a</literal>;
                  <sbr/> <literal moreinfo="none">const_iterator</literal> for constant <literal moreinfo="none">a</literal>
                </para>
              </entry>
              <entry>
                <para>
                   
                </para>
              </entry>
              <entry>
                <para>
                  (Note A)
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.cshoot()</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">const_iterator</literal>
                </para>
              </entry>
              <entry>
                <para>
                   
                </para>
              </entry>
              <entry>
                <para>
                  (Note A)
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">typename X::template rebind&lt;U&gt;::other</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">Y</literal>
                </para>
              </entry>
              <entry>
                <para>
                  For all <literal moreinfo="none">U</literal> (including <literal moreinfo="none">T</literal>),
                  <literal moreinfo="none">Y::template rebind&lt;T&gt;::other</literal> is <literal moreinfo="none">X</literal>.
                </para>
              </entry>
              <entry>
                <para>
                  compile time
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
        Notes: Those entries marked "(Note A)" should have at worst linear
        complexity. See the individual hierarchy containers for specific complexity.
      </para>
      </simplesect> <simplesect role="std_requisite">
      <para>
        <literal moreinfo="none">root()</literal> and <literal moreinfo="none">croot()</literal> return a cursor
        which is the on-top value for the hierarchy. <literal moreinfo="none">shoot()</literal> and
        <literal moreinfo="none">cshoot()</literal> return a cursor which is the past-the-end value
        that is found one past the hierarchy's rightmost element. If the hierarchy
        is empty, then <literal moreinfo="none">root() == shoot();</literal>
      </para>
      </simplesect> <simplesect role="std_requisite">
      <para>
        Copy constructors for all hierarchy types defined in this clause copy the
        allocator argument from their respective first parameters. All other constructors
        for these hierarchy types take an <literal moreinfo="none">Allocator&amp;</literal> argument
        (20.6.9). A copy of this argument is used for any memory allocation performed,
        by these constructors and by all member functions, during the lifetime of
        each hierarchy object. In all hierarchy types defined in this clause, the
        member <literal moreinfo="none">get_allocator()</literal> returns a copy of the <literal moreinfo="none">Allocator</literal>
        object used to construct the hierarchy.
      </para>
      </simplesect> <simplesect role="std_requisite">
      <para>
        The member class template <literal moreinfo="none">rebind</literal> in the table above is
        effectively a typedef template: if the name <literal moreinfo="none">Hierarchy</literal>
        is bound to <literal moreinfo="none">SomeHierarchy&lt;T&gt;</literal>, then <literal moreinfo="none">Hierarchy::rebind&lt;U&gt;::other</literal>
        is the same type as <literal moreinfo="none">SomeHierarchy&lt;U&gt;</literal>. Additionally,
        because of the related assertion, given <literal moreinfo="none">SomeHierarchy&lt;T,R0,...,Rn&gt;</literal>
        for all template arguments present is bound to the name <literal moreinfo="none">Hierarchy</literal>,
        then <literal moreinfo="none">Hierarchy::rebind&lt;U&gt;::other</literal> is the same type
        as <literal moreinfo="none">SomeHierarchy&lt;U,S0,...,Sn&gt;</literal> such that the types
        <literal moreinfo="none">S0</literal> through <literal moreinfo="none">Sn</literal> are the same as <literal moreinfo="none">R0</literal>
        through <literal moreinfo="none">Rn</literal>, respectively, when <literal moreinfo="none">U</literal> is
        the same type as <literal moreinfo="none">T</literal>.
      </para>
      </simplesect> <simplesect role="std_requisite">
      <para>
        A hierarchy satisfying the requirements shown in Table 3 is called a <emphasis>mutable
        hierarchy</emphasis>.
      </para>
      <table frame="all" id="tree.req.general.table3">
        <title>Mutable hierarchy requirements</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>
                <para>
                  expression
                </para>
              </entry>
              <entry>
                <para>
                  return type
                </para>
              </entry>
              <entry>
                <para>
                  assertion/note <sbr/> pre/post-condition
                </para>
              </entry>
              <entry>
                <para>
                  complexity
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">emplace</phrase><phrase role="special">(</phrase><phrase role="identifier">p</phrase><phrase role="special">,</phrase>
                  <phrase role="identifier">args</phrase><phrase role="special">);</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">cursor</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <emphasis>Requires:</emphasis> <literal moreinfo="none">T</literal> is <literal moreinfo="none">EmplaceConstructable</literal>
                  into X from <literal moreinfo="none">args</literal>, T is also <literal moreinfo="none">MoveInsertable</literal>
                  into <literal moreinfo="none">X</literal> and <literal moreinfo="none">MoveAssignable</literal>.
                  <sbr/> <emphasis>Effects:</emphasis> Inserts an object of type
                  <literal moreinfo="none">T</literal> constructed with <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">forward</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Args</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">args</phrase><phrase role="special">)...</phrase></computeroutput> before <literal moreinfo="none">p</literal>.
                </para>
              </entry>
              <entry>
                <para>
                  (Note A)
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">p</phrase><phrase role="special">,</phrase><phrase role="identifier">t</phrase><phrase role="special">)</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">cursor</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <emphasis>Requires:</emphasis> <literal moreinfo="none">T</literal> shal be <literal moreinfo="none">CopyInsertable</literal>
                  into <literal moreinfo="none">X</literal>. <emphasis>Effects:</emphasis> Inserts
                  a copy of <literal moreinfo="none">t</literal> before <literal moreinfo="none">p</literal>.
                </para>
              </entry>
              <entry>
                <para>
                  (Note A)
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">p</phrase><phrase role="special">,</phrase><phrase role="identifier">rv</phrase><phrase role="special">)</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">cursor</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <emphasis>Requires:</emphasis> <literal moreinfo="none">T</literal> shal be <literal moreinfo="none">MoveInsertable</literal>
                  into <literal moreinfo="none">X</literal>. <emphasis>Effects:</emphasis> Inserts
                  a copy of <literal moreinfo="none">rv</literal> before <literal moreinfo="none">p</literal>.
                </para>
              </entry>
              <entry>
                <para>
                  (Note A)
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">q</phrase><phrase role="special">)</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">void</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <emphasis>Effects:</emphasis> Deletes the subtree of <literal moreinfo="none">q</literal>
                  and the element <literal moreinfo="none">q</literal> points to. <sbr/> pre: <literal moreinfo="none">q</literal>
                  is dereferenceable.
                </para>
              </entry>
              <entry>
                <para>
                  Should be at worst linear in the the number of elements in the
                  subtree of <literal moreinfo="none">q</literal> plus the distance to <literal moreinfo="none">q</literal>'s
                  parent's <literal moreinfo="none">end()</literal>.
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">clear</phrase><phrase role="special">()</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">void</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <emphasis>Effects:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">while</phrase>
                  <phrase role="special">(</phrase><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">())</phrase> <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">());</phrase></computeroutput> <sbr/> post: <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()</phrase>
                  <phrase role="special">==</phrase> <phrase role="number">0</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  (Note A)
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
        Notes: Those entries marked "(Note A)" should have at worst linear
        complexity. See the individual hierarchy containers for specific complexity.
      </para>
      </simplesect> <simplesect role="std_requisite">
      <para>
        The cursor returned from <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">p</phrase><phrase role="special">,</phrase>
        <phrase role="identifier">t</phrase><phrase role="special">)</phrase></computeroutput>
        points to the copy of <literal moreinfo="none">t</literal> inserted into <literal moreinfo="none">a</literal>.
        Its parent cursor is the same as that of <literal moreinfo="none">p</literal>.
      </para>
      </simplesect> <simplesect role="std_requisite">
      <para>
        The cursor returned from <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">p</phrase><phrase role="special">,</phrase>
        <phrase role="identifier">rv</phrase><phrase role="special">)</phrase></computeroutput>
        points to the copy of <literal moreinfo="none">rv</literal> inserted into <literal moreinfo="none">a</literal>.
        Its parent cursor is the same as that of <literal moreinfo="none">p</literal>.
      </para>
      </simplesect> <simplesect role="std_requisite">
      <para>
        The cursor returnd from <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">emplace</phrase><phrase role="special">(</phrase><phrase role="identifier">p</phrase><phrase role="special">,</phrase>
        <phrase role="identifier">args</phrase><phrase role="special">)</phrase></computeroutput>
        points to the new element constructed from <literal moreinfo="none">args</literal> into
        <literal moreinfo="none">a</literal>. Its parent cursor is the same as that of <literal moreinfo="none">p</literal>.
      </para>
      </simplesect>
    </section>
  </section>
  <section id="tree.plain">
    <title><link linkend="tree.plain">Plain hierarchies <phrase role="std_section_label">[hierarchy.plain]</phrase></link></title>
    <simplesect role="std_requisite">
    <para>
      A hierarchy is called a <emphasis>plain hierarchy</emphasis> if its <literal moreinfo="none">cursor</literal>
      and <literal moreinfo="none">const_cursor</literal> types satisfy the requirements of a plain
      cursor.
    </para>
    </simplesect> <simplesect role="std_requisite">
    <para>
      The library provides one native kind of plain hierarchy, <literal moreinfo="none">nary_tree</literal>,
      and a hierarchy adaptor that in turn yields a plain hierarchy, <literal moreinfo="none">forest_tree</literal>.
    </para>
    </simplesect> <simplesect role="std_requisite">
    <para>
      For a mutable plain hierarchy, the following expressions as shown in Table
      4, are additionally required to be valid:
    </para>
    <table frame="all" id="tree.plain.table4">
      <title>Plain hierarchy requirements</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>
              <para>
                expression
              </para>
            </entry>
            <entry>
              <para>
                return type
              </para>
            </entry>
            <entry>
              <para>
                assertion/note <sbr/> pre/post-condition
              </para>
            </entry>
            <entry>
              <para>
                complexity
              </para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>
                <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">p</phrase><phrase role="special">,</phrase><phrase role="identifier">c</phrase><phrase role="special">)</phrase></computeroutput>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">cursor</literal>
              </para>
            </entry>
            <entry>
              <para>
                <emphasis>Requires:</emphasis> <literal moreinfo="none">T</literal> shall be <literal moreinfo="none">CopyInsertable</literal>
                into <literal moreinfo="none">X</literal> <sbr/> <emphasis>Effects:</emphasis> Inserts
                a copy of the subtree of <literal moreinfo="none">c</literal> before <literal moreinfo="none">p</literal>.
                <sbr/> pre: <literal moreinfo="none">c</literal> is dereferenceable.
              </para>
            </entry>
            <entry>
              <para>
                Should be at worst linear in the the number of elements in the subtree
                of <literal moreinfo="none">c</literal> plus the distance to <literal moreinfo="none">p</literal>'s
                parent's <literal moreinfo="none">end()</literal>.
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">p</phrase><phrase role="special">,</phrase><phrase role="identifier">t</phrase><phrase role="special">)</phrase></computeroutput>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">cursor</literal>
              </para>
            </entry>
            <entry>
              <para>
                <emphasis>Requires:</emphasis> <literal moreinfo="none">T</literal> shall be <literal moreinfo="none">CopyInsertable</literal>
                into <literal moreinfo="none">X</literal> <sbr/> <emphasis>Effects:</emphasis> Inserts
                a copy of <literal moreinfo="none">t</literal> as a child of <literal moreinfo="none">p</literal>'s
                parent and new parent of <literal moreinfo="none">p</literal> and its siblings.
                <sbr/> pre: <literal moreinfo="none">c</literal> is dereferenceable.
              </para>
            </entry>
            <entry>
              <para>
                Linear in the the number <literal moreinfo="none">p</literal>'s siblings.
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">p</phrase><phrase role="special">,</phrase><phrase role="identifier">rv</phrase><phrase role="special">)</phrase></computeroutput>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">cursor</literal>
              </para>
            </entry>
            <entry>
              <para>
                <emphasis>Requires:</emphasis> <literal moreinfo="none">T</literal> shall be <literal moreinfo="none">MoveInsertable</literal>
                into <literal moreinfo="none">X</literal>. <emphasis>Effects:</emphasis> Inserts
                a copy of <literal moreinfo="none">rv</literal> as a child of <literal moreinfo="none">p</literal>'s
                parent and new parent of <literal moreinfo="none">p</literal> and its siblings.
              </para>
            </entry>
            <entry>
              <para>
                Linear in the the number <literal moreinfo="none">p</literal>'s siblings.
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    </simplesect> <simplesect role="std_requisite">
    <para>
      The cursor returned from <literal moreinfo="none">a.insert(p,c)</literal> points to the copy
      of the element that <literal moreinfo="none">c</literal> points to, inserted into <literal moreinfo="none">a</literal>.
      Its parent cursor is the same as that of <literal moreinfo="none">p</literal>.
    </para>
    </simplesect>
  </section>
  <section id="tree.multiway">
    <title><link linkend="tree.multiway">Multiway hierarchies <phrase role="std_section_label">[hierarchy.multiway]</phrase></link></title>
    <simplesect role="std_requisite">
    <para>
      A hierarchy is called a <emphasis>multiway hierarchy</emphasis> if its <literal moreinfo="none">cursor</literal>
      and <literal moreinfo="none">const_cursor</literal> types satisfy the requirements of a multiway
      cursor.
    </para>
    </simplesect> <simplesect role="std_requisite">
    <para>
      The library provides one native kind of multiway hierarchy, <literal moreinfo="none">binary_tree</literal>,
      and a hierarchy adaptor that in turn yields a multiway hierarchy, <literal moreinfo="none">multiway_tree</literal>.
    </para>
    </simplesect> <simplesect role="std_requisite">
    <para>
      For a mutable multiway hierarchy, the semantics of some expressions from Table
      3 are modified as shown in Table 5.
    </para>
    <table frame="all" id="tree.multiway.table5">
      <title>Multiway hierarchy requirements</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>
              <para>
                expression
              </para>
            </entry>
            <entry>
              <para>
                return type
              </para>
            </entry>
            <entry>
              <para>
                assertion/note <sbr/> pre/post-condition
              </para>
            </entry>
            <entry>
              <para>
                complexity
              </para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>
                <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">q</phrase><phrase role="special">)</phrase></computeroutput>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">void</literal>
              </para>
            </entry>
            <entry>
              <para>
                Deletes the subtree of <literal moreinfo="none">q</literal>.<sbr/> If <literal moreinfo="none">q</literal>
                is dereferenceable, the expression also deletes the element <literal moreinfo="none">q</literal>
                points to. <sbr/> If <literal moreinfo="none">q</literal> is past-the-end, the expression
                deletes the element <literal moreinfo="none">q</literal>'s predecessor points to.
                <sbr/> If after either of these steps <literal moreinfo="none">q</literal> has only
                a non-empty past-the-end child, that child's children become <literal moreinfo="none">q</literal>'s
                children instead. Finally, that child is deleted. <sbr/> pre: <literal moreinfo="none">q</literal>
                is internal.
              </para>
            </entry>
            <entry>
              <para>
                Should be at worst linear in the the number of elements in the subtree
                of <literal moreinfo="none">c</literal> plus the distance to <literal moreinfo="none">p</literal>'s
                parent's <literal moreinfo="none">end()</literal>.
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    </simplesect>
  </section>
  <section id="tree.tree">
    <title><link linkend="tree.tree">Trees <phrase role="std_section_label">[hierarchy.tree]</phrase></link></title>
    <simplesect role="std_requisite">
    <para>
      Headers <literal moreinfo="none">&lt;binary_tree&gt;</literal>, <literal moreinfo="none">&lt;nary_tree&gt;</literal>,
      <literal moreinfo="none">&lt;forest_tree&gt;</literal>, and <literal moreinfo="none">&lt;multiway_tree&gt;</literal>.
    </para>
    <para>
      <emphasis role="bold">Header <literal moreinfo="none">&lt;binary_tree&gt;</literal> synopsis</emphasis>
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase> <phrase role="special">=</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>
      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase>
        <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase>
        <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
    <para>
      <emphasis role="bold">Header <literal moreinfo="none">&lt;nary_tree&gt;</literal> synopsis</emphasis>
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase> <phrase role="special">=</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
      <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>
    <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
    <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase>
        <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase>
        <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
    <para>
      <emphasis role="bold">Header <literal moreinfo="none">&lt;forest_tree&gt;</literal> synopsis</emphasis>
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">forest_tree</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>
    <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
    <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase>
        <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase>
        <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
    <para>
      <emphasis role="bold">Header <literal moreinfo="none">&lt;multiway_tree&gt;</literal> synopsis</emphasis>
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">multiway_tree</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>
      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase>
        <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase>
        <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
    </simplesect>
<section id="tree.tree.bintree">
      <title><link linkend="tree.tree.bintree">Class template <literal moreinfo="none">binary_tree</literal>
      <phrase role="std_section_label">[hierarchy.bintree]</phrase></link></title>
      <section id="tree.tree.bintree.overview">
        <title><link linkend="tree.tree.bintree.overview">Class template <literal moreinfo="none">binary_tree</literal>
        overview <phrase role="std_section_label">[hiearchy.bintree.overview]</phrase></link></title>
        <para>
          A <literal moreinfo="none">binary_tree</literal> is a kind of hierarchy that satisfies
          multiway hierarchy requirements. Additionally, it supports (inorder-invariant)
          cursor rotation. Descriptions are provided here only for operations on
          <literal moreinfo="none">binary_tree</literal> that are not described in one of these tables
          or for operations where there is additional semantic information.
        </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Allocator</phrase> <phrase role="special">=</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">class</phrase> <phrase role="identifier">binary_tree</phrase>
  <phrase role="special">{</phrase>
  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="comment">// 23.7.4.1.2, types:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">reference</phrase>            <phrase role="identifier">reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_reference</phrase>      <phrase role="identifier">const_reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">size_type</phrase>            <phrase role="identifier">size_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">difference_type</phrase>      <phrase role="identifier">difference_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">T</phrase>                                             <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Allocator</phrase>                                     <phrase role="identifier">allocator_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">pointer</phrase>              <phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_pointer</phrase>        <phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">U</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">rebind</phrase> <phrase role="special">{</phrase>
      <phrase role="keyword">typedef</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">U</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="keyword">template</phrase> <phrase role="identifier">rebind</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">other</phrase> <phrase role="special">&gt;</phrase>
        <phrase role="identifier">other</phrase><phrase role="special">;</phrase>
    <phrase role="special">};</phrase>

    <phrase role="comment">// 23.7.4.1.3, construct/copy/destroy:</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">binary_tree</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">,</phrase>
        <phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
    <phrase role="identifier">binary_tree</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">value_type</phrase><phrase role="special">,</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">binary_tree</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&amp;&amp;);</phrase>
    <phrase role="identifier">binary_tree</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&amp;,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;);</phrase>
    <phrase role="identifier">binary_tree</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&amp;&amp;,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;);</phrase>
    <phrase role="special">~</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">value_type</phrase><phrase role="special">,</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&gt;&amp;</phrase>
      <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">value_type</phrase><phrase role="special">,</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&gt;&amp;</phrase>
      <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&gt;&amp;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">allocator_type</phrase> <phrase role="identifier">get_allocator</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// 23.7.4.1.4, cursors:</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">root</phrase><phrase role="special">()</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">croot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">()</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase> <phrase role="keyword">const</phrase><phrase role="special">()</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// capacity:</phrase>
    <phrase role="keyword">bool</phrase>      <phrase role="identifier">empty</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">max_size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// 23.7.4.1.5, modifiers:</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">const_cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">const_cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">const_cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">rotate</phrase><phrase role="special">(</phrase><phrase role="identifier">const_cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">value_type</phrase><phrase role="special">,</phrase> <phrase role="identifier">allocator_Type</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
  <phrase role="special">};</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="keyword">const</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="keyword">const</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="keyword">const</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="keyword">const</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="comment">// 23.7.4.1.6, specialized algorithms:</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
      </section>
      <section id="tree.tree.bintree.types">
        <title><link linkend="tree.tree.bintree.types"><literal moreinfo="none">binary_tree</literal>
        types <phrase role="std_section_label">[hierarchy.bintree.types]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis> <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis> <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_requisite">
        <para>
          Both <literal moreinfo="none">cursor</literal> and <literal moreinfo="none">const_cursor</literal> have
          to fulfill the multiway cursor ([cursor.flavors]) and ascending random
          access cursor ([ascending.random.access.cursors]) requirements.
        </para>
        </simplesect> <simplesect role="std_requisite">
        <para>
          Additionally, for any instance a of either type <literal moreinfo="none">cursor</literal>
          or <literal moreinfo="none">const_cursor</literal>, <literal moreinfo="none">a.max_size() == 1</literal>.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.bintree.cons">
        <title><link linkend="tree.tree.bintree.cons"><literal moreinfo="none">binary_tree</literal>
        constructors, copy, and assignment <phrase role="std_section_label">[hierarchy.bintree.cons]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">explicit</phrase> <phrase role="identifier">binary_tree</phrase> <phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">binary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
<phrase role="identifier">binary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Complexity:</emphasis> The constructor <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase>
          <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase>
          <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
          <phrase role="identifier">vector</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">)</phrase></computeroutput> makes only <literal moreinfo="none">N</literal> calls
          to the copy constructor of <literal moreinfo="none">T</literal> (where <literal moreinfo="none">N</literal>
          is the number of elements in <literal moreinfo="none">subtree</literal>) and no reallocations
          if the cursor <literal moreinfo="none">subtree</literal> is of (either descending or ascending)
          forward, bidirectional, or random access categories. It does at most <literal moreinfo="none">2N</literal>
          calls to the copy constructor of <literal moreinfo="none">T</literal> and <literal moreinfo="none">logN</literal>
          reallocations if they are just cursors, since it is impossible to determine
          the size of <literal moreinfo="none">subtree</literal> and then do copying.
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Effects:</emphasis>
        </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase> <phrase role="identifier">i</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">root</phrase><phrase role="special">().</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase> <phrase role="special">*</phrase><phrase role="identifier">i</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect>
      </section>
      <section id="tree.tree.bintree.cursors">
        <title><link linkend="tree.tree.bintree.cursors"><literal moreinfo="none">binary_tree</literal>
        cursors <phrase role="std_section_label">[hierarchy.bintree.cursors]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Complexity:</emphasis> constant
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">();</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Returns:</emphasis> A cursor to the <literal moreinfo="none">binary_tree</literal>'s
          first element in inorder (see [tr.order.iterators]).
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Complexity:</emphasis> constant.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.bintree.modifiers">
        <title><link linkend="tree.tree.bintree.modifiers"><literal moreinfo="none">binary_tree</literal>
        modifiers <phrase role="std_section_label">[hierarchy.bintree.modifiers]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase> <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
<phrase role="identifier">cursor</phrase> <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">const_cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Notes:</emphasis> Does not affect the validity of cursors and
          references.
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Effect:</emphasis> Let <literal moreinfo="none">parent</literal> be <literal moreinfo="none">position</literal>'s
          parent; if <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">parent</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">parent</phrase><phrase role="special">.</phrase><phrase role="identifier">max_size</phrase><phrase role="special">()</phrase></computeroutput>, insert a copy of <literal moreinfo="none">x</literal>
          before <literal moreinfo="none">position</literal>, as child of <literal moreinfo="none">parent</literal>;
          Otherwise, if <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">empty</phrase><phrase role="special">()</phrase></computeroutput>, insert a copy of <literal moreinfo="none">x</literal>
          as child of <literal moreinfo="none">position</literal>; and if <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">!</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">empty</phrase><phrase role="special">()</phrase></computeroutput>,
          insert a copy of <literal moreinfo="none">x</literal> as parent of <literal moreinfo="none">position</literal>'s
          current child, as new child of <literal moreinfo="none">position</literal>.
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          Complexity: constant
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">cursor</phrase> <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Notes:</emphasis> Does not affect the validity of cursors and
          references.
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Effects:</emphasis> as above, substituting <literal moreinfo="none">InputCursor
          subtree</literal> to insert instead of <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">const</phrase>
          <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase>
          <phrase role="identifier">x</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Complexity:</emphasis> linear in the number of elements in subtree.
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">rotate</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Precondition:</emphasis> <literal moreinfo="none">position</literal> and its
          parent are internal and non-on-top
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Effects:</emphasis> Performs a left tree rotation around the
          parent of <literal moreinfo="none">position</literal> if <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">parity</phrase><phrase role="special">()</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase></computeroutput>
          or a right tree rotation if <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">parity</phrase><phrase role="special">()</phrase> <phrase role="special">==</phrase> <phrase role="number">1</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Postcondition:</emphasis> If <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">par</phrase>
          <phrase role="special">==</phrase> <phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">parity</phrase><phrase role="special">()</phrase></computeroutput> as of before the rotation, then, after
          the rotation:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()</phrase></computeroutput> yields the same value it yielded
              before the rotation
            </para>
          </listitem>
          <listitem>
            <para>
              <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">parity</phrase><phrase role="special">()</phrase>
              <phrase role="special">==</phrase> <phrase role="special">!</phrase><phrase role="identifier">par</phrase></computeroutput>
            </para>
          </listitem>
          <listitem>
            <para>
              <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*(((</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[</phrase><phrase role="identifier">par</phrase><phrase role="special">]).</phrase><phrase role="identifier">begin</phrase><phrase role="special">())</phrase></computeroutput> yields what <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*(</phrase><phrase role="identifier">p</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">())</phrase></computeroutput>
              yielded before, if <literal moreinfo="none">p</literal> was <literal moreinfo="none">position</literal>'s
              parent
            </para>
          </listitem>
          <listitem>
            <para>
              <literal moreinfo="none">position</literal>'s parent's value is what <literal moreinfo="none">position</literal>'s
              parent's parent's value yielded before. The ancestors of that cursor,
              and their structure, remain unchanged
            </para>
          </listitem>
          <listitem>
            <para>
              <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[!</phrase><phrase role="identifier">par</phrase><phrase role="special">]</phrase></computeroutput>'s subtree is what <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[!</phrase><phrase role="identifier">par</phrase><phrase role="special">]</phrase></computeroutput>'s
              was before.
            </para>
          </listitem>
          <listitem>
            <para>
              <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">((</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()[!</phrase><phrase role="identifier">par</phrase><phrase role="special">]).</phrase><phrase role="identifier">begin</phrase><phrase role="special">())\[</phrase><phrase role="identifier">par</phrase><phrase role="special">]</phrase></computeroutput>'s subtree is what <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">(</phrase><phrase role="identifier">p</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[!</phrase><phrase role="identifier">par</phrase><phrase role="special">]</phrase></computeroutput>'s
              was before, if <literal moreinfo="none">p</literal> was <literal moreinfo="none">position</literal>'s
              parent.
            </para>
          </listitem>
          <listitem>
            <para>
              <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">((</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()[!</phrase><phrase role="identifier">par</phrase><phrase role="special">]).</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[</phrase><phrase role="identifier">par</phrase><phrase role="special">]</phrase></computeroutput>'s subtree is what <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[!</phrase><phrase role="identifier">par</phrase><phrase role="special">]</phrase></computeroutput>'s
              was before.
            </para>
          </listitem>
        </itemizedlist>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Complexity:</emphasis> constant
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Notes:</emphasis> Does not affect the validity of cursors and
          references. Tree rotations are important inorder-preserving (see [tr.order.iterators])
          operations on binary trees that are especially required by balancers.
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Notes:</emphasis> Invalidates only the cursors and references
          to the erased elements.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.bintree.special">
        <title><link linkend="tree.tree.bintree.special"><literal moreinfo="none">binary_tree</literal>
        specialized algorithms <phrase role="std_section_label">[hierarchy.bintree.special]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
              <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Effects:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">)</phrase></computeroutput>;
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">inorder_first</phrase><phrase role="special">())</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Complexity:</emphasis> constant
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">inorder_cfirst</phrase><phrase role="special">())</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Complexity:</emphasis> constant
        </para>
        </simplesect>
      </section>
    </section>
    <section id="tree.tree.narytree">
      <title><link linkend="tree.tree.narytree">Class template <literal moreinfo="none">nary_tree</literal>
      <phrase role="std_section_label">[narytree]</phrase></link></title>
      <section id="tree.tree.narytree.synopsis">
        <title><link linkend="tree.tree.narytree.synopsis"><literal moreinfo="none">nary_tree</literal>
        overview <phrase role="std_section_label">[narytree.overview]</phrase></link></title>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase> <phrase role="special">=</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">allocator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">class</phrase> <phrase role="identifier">nary_tree</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="comment">// types:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">reference</phrase>            <phrase role="identifier">reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_reference</phrase>      <phrase role="identifier">const_reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">size_type</phrase>            <phrase role="identifier">size_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">difference_type</phrase>      <phrase role="identifier">difference_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">T</phrase>                                             <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Alloc</phrase>                                         <phrase role="identifier">allocator_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">pointer</phrase>              <phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_pointer</phrase>        <phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">U</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">rebind</phrase> <phrase role="special">{</phrase>
      <phrase role="keyword">typedef</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">U</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">::</phrase><phrase role="keyword">template</phrase> <phrase role="identifier">rebind</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">other</phrase> <phrase role="special">&gt;</phrase>
        <phrase role="identifier">other</phrase><phrase role="special">;</phrase>
    <phrase role="special">};</phrase>

    <phrase role="comment">// construct/copy/destroy:</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">,</phrase>
        <phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
    <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">value_type</phrase><phrase role="special">,</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&amp;&amp;);</phrase>
    <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&amp;,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;);</phrase>
    <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&amp;&amp;,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;);</phrase>
    <phrase role="special">~</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">value_type</phrase><phrase role="special">,</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&gt;&amp;</phrase>
      <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">value_type</phrase><phrase role="special">,</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">value_type</phrase><phrase role="special">,</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&gt;&amp;</phrase>
      <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">value_type</phrase><phrase role="special">,</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&gt;&amp;&amp;);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">allocator_type</phrase> <phrase role="identifier">get_allocator</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// cursors:</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">root</phrase><phrase role="special">()</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">croot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">()</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase> <phrase role="keyword">const</phrase><phrase role="special">()</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// capacity:</phrase>
    <phrase role="keyword">bool</phrase>      <phrase role="identifier">empty</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">max_size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">shrink_to_fit</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>

    <phrase role="comment">// modifiers:</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;);</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;&amp;);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;);</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;&amp;);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">value_type</phrase><phrase role="special">,</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
  <phrase role="special">};</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="comment">// specialized algorithms:</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
      </section>
      <section id="tree.tree.narytree.types">
        <title><link linkend="tree.tree.narytree.types"><literal moreinfo="none">nary_tree</literal>
        types <phrase role="std_section_label">[narytree.types]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis> <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis> <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          Both <literal moreinfo="none">cursor</literal> and <literal moreinfo="none">const_cursor</literal> have
          to fulfill the plain cursor ([cursor.flavors]) and ascending random access
          cursor ([ascending.random.access.cursors]) requirements.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.narytree.cons">
        <title><link linkend="tree.tree.narytree.cons"><literal moreinfo="none">nary_tree</literal>
        constructors, copy, and assignment <phrase role="std_section_label">[narytree.cons]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">explicit</phrase> <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">allocator_type</phrase><phrase role="special">());</phrase>
<phrase role="identifier">nary_tree</phrase> <phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Complexity:</emphasis> The constructor <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase>
          <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase>
          <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
          <phrase role="identifier">vector</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">)</phrase></computeroutput> makes only <literal moreinfo="none">N</literal> calls
          to the copy constructor of <literal moreinfo="none">T</literal> (where <literal moreinfo="none">N</literal>
          is the number of elements in <literal moreinfo="none">subtree</literal>) and no reallocations
          if the cursor <literal moreinfo="none">subtree</literal> is of (either descending or ascending)
          forward, bidirectional, or random access categories. It does at most <literal moreinfo="none">2N</literal>
          calls to the copy constructor of <literal moreinfo="none">T</literal> and <literal moreinfo="none">logN</literal>
          reallocations if they are just cursors, since it is impossible to determine
          the size of <literal moreinfo="none">subtree</literal> and then do copying.
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Effects:</emphasis>
        </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase> <phrase role="identifier">i</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">root</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase> <phrase role="special">*</phrase><phrase role="identifier">i</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect>
      </section>
      <section id="tree.tree.narytree.cursors">
        <title><link linkend="tree.tree.narytree.cursors"><literal moreinfo="none">nary_tree</literal>
        cursors <phrase role="std_section_label">[narytree.cursors]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Complexity:</emphasis> constant
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">()</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Returns:</emphasis> A cursor to the nary_tree's first element
          in inorder (see [order.iterators]).
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Complexity:</emphasis> constant.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.narytree.capacity">
        <title><link linkend="tree.tree.narytree.capacity"><literal moreinfo="none">nary_tree</literal>
        capacity <phrase role="std_section_label">[narytree.capacity]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">size_type</phrase> <phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">noexcept</phrase><phrase role="special">;</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Returns:</emphasis> The total number of child elements that the
          cursor <literal moreinfo="none">position</literal> can hold without requiring reallocation.
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Effects:</emphasis> A directive that informs an <literal moreinfo="none">nary_tree</literal>
          of a planned change in a given cursor's size, so that it can manage the
          storage allocation accordingly. After <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase></computeroutput>,
          <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">)</phrase></computeroutput>
          is greater or equal to the <literal moreinfo="none">size_type</literal> argument <literal moreinfo="none">n</literal>
          of reserve if reallocation happens; and equal to the previous value of
          <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">)</phrase></computeroutput>
          otherwise. Reallocation happens at this point if and only if the current
          capacity is less than the <literal moreinfo="none">size_type</literal> argument <literal moreinfo="none">n</literal>
          of <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">()</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Complexity:</emphasis> It does not change the size of the <literal moreinfo="none">nary_tree</literal>
          and takes at most linear time in <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Notes:</emphasis> Reallocation invalidates all the references,
          pointers, and cursors referring to the child elements of <literal moreinfo="none">position</literal>.
          It is guaranteed that no reallocation takes place during insertions to
          <literal moreinfo="none">position</literal> that happen after a call to <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">()</phrase></computeroutput> until the time when an insertion would
          make <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()</phrase></computeroutput>
          greater than the size specified in the most recent call to <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">()</phrase></computeroutput>.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.narytree.modifiers">
        <title><link linkend="tree.tree.narytree.modifiers"><literal moreinfo="none">nary_tree</literal>
        modifiers <phrase role="std_section_label">[narytree.modifiers]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;);</phrase>
<phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;&amp;);</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
<phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;);</phrase>
<phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;&amp;);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Notes:</emphasis> Does not affect the validity of cursors and
          references.
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Notes:</emphasis> Invalidates only the cursors and references
          to the erased elements.
        </para>
        </simplesect>
      </section>
      <section id="tree.tree.narytree.special">
        <title><link linkend="tree.tree.narytree.special"><literal moreinfo="none">nary_tree</literal>
        specialized algorithms <phrase role="std_section_label">[narytree.special]</phrase></link></title>
        <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
              <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Effects:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">);</phrase></computeroutput>
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">inorder_first</phrase><phrase role="special">())</phrase></computeroutput>.
        </para>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Complexity:</emphasis> constant
        </para>
        </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
        </simplesect> <simplesect role="std_specification">
        <para>
          <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">inorder_cfirst</phrase><phrase role="special">())</phrase></computeroutput>.
        </para>
        </simplesect>
      </section>
    </section>
    <section id="tree.tree.adaptors">
      <title><link linkend="tree.tree.adaptors">Hierarchy adaptors <phrase role="std_section_label">[hierarchy.adaptors]</phrase></link></title>
      <section id="tree.tree.adaptors.general">
        <title><link linkend="tree.tree.adaptors.general">In general <phrase role="std_section_label">[hiearchy.adaptors.general]</phrase></link></title>
        <para>
          Hierarchy adaptors each take a <literal moreinfo="none">Hierarchy</literal> template parameter,
          and each of their constructors takes a <literal moreinfo="none">Hierarchy</literal> reference
          argument. This hierarchy is copied into the <literal moreinfo="none">Hierarchy</literal>
          member of each adapter. Most hierarchy adaptors satisfy most of the hierarchy
          requirements (except for anything that deals with allocators, as storage
          management is done by the adaptees). The exception is the group of balancing
          hierarchy adaptors ([hierarchy.balance]), whose members satisfy most of
          the requirements of a container, of a sequence and most of the optional
          sequence requirements instead (again except for anything allocation related,
          and some other exceptions).
        </para>
      </section>
      <section id="tree.tree.adaptors.foresttree">
        <title><link linkend="tree.tree.adaptors.foresttree">Template class <literal moreinfo="none">forest_tree</literal>
        <phrase role="std_section_label">[foresttree]</phrase></link></title> <simplesect role="std_definition">
        <para>
          A <literal moreinfo="none">forest_tree</literal> is a kind of mutable plain hierarchy that
          is instantiated with a mutable multiway hierarchy that has insertion semantics
          as a <literal moreinfo="none">binary_tree</literal> ([bintree.modifiers], §1)), and whose
          cursor types <literal moreinfo="none">cursor</literal> and <literal moreinfo="none">const_cursor</literal>
          satisfy a <literal moreinfo="none">binary_tree</literal>'s <literal moreinfo="none">cursor</literal> and
          <literal moreinfo="none">const_cursor</literal> type requirements ([bintree.types], §1-2)).
        </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">class</phrase> <phrase role="identifier">forest_tree</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Hierarchy</phrase>                                     <phrase role="identifier">hierarchy_type</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
    <phrase role="identifier">hierarchy_type</phrase> <phrase role="identifier">h</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="comment">// types:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">T</phrase>                                             <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">pointer</phrase>              <phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_pointer</phrase>        <phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">reference</phrase>            <phrase role="identifier">reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_reference</phrase>      <phrase role="identifier">const_reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">size_type</phrase>            <phrase role="identifier">size_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">difference_type</phrase>      <phrase role="identifier">difference_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">U</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">rebind</phrase> <phrase role="special">{</phrase>
      <phrase role="keyword">typedef</phrase> <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">U</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="keyword">template</phrase> <phrase role="identifier">rebind</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">other</phrase> <phrase role="special">&gt;</phrase>
        <phrase role="identifier">other</phrase><phrase role="special">;</phrase>
    <phrase role="special">};</phrase>

    <phrase role="comment">// construct/copy/destroy:</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">forest_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">forest_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">forest_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase>
      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>

    <phrase role="comment">// cursors:</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">root</phrase><phrase role="special">()</phrase>    <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">root</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">croot</phrase><phrase role="special">()</phrase>   <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">croot</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// capacity:</phrase>
    <phrase role="keyword">bool</phrase>      <phrase role="identifier">empty</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">empty</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase>  <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">max_size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// modifiers:</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
  <phrase role="special">};</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="comment">// specialized algorithms:</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
        </simplesect>
<section id="tree.tree.adaptors.foresttree.types">
          <title><link linkend="tree.tree.adaptors.foresttree.types"><literal moreinfo="none">forest_tree</literal>
          types <phrase role="std_section_label">[foresttree.types]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Notes:</emphasis> If (the adaptee) <literal moreinfo="none">Hierarchy</literal>'s
            cursor types are at least ascending bidirectional cursors, both <literal moreinfo="none">cursor</literal>
            and <literal moreinfo="none">const_cursor</literal> are ascending bidirectional cursors.
            Otherwise, they are descending forward cursors. The adaptee binary tree
            is "tilted" to yield an n-ary tree, meaning that the operational
            semantics of the adaptor cursor are as follows in terms of the adaptee
            cursor (only valid if present in the adaptor cursor's category; only
            given for mutable versions of expressions, const ones as according; expressions
            missing from the list mean operational semantics and complexity are for
            <literal moreinfo="none">b</literal> as they are for <literal moreinfo="none">f</literal>):
          </para>
          <table frame="all" id="tree.tree.adaptors.foresttree.types.table6">
            <title>forest_tree/binary tree cursor operational semantics correspondences</title>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>
                    <para>
                      adaptor cursor <literal moreinfo="none">f</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      adaptee cursor <literal moreinfo="none">b</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      complexity
                    </para>
                  </entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">f</phrase> <phrase role="special">=</phrase>
                      <phrase role="identifier">f</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">()</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">while</phrase> <phrase role="special">(!</phrase><phrase role="identifier">b</phrase><phrase role="special">.</phrase><phrase role="identifier">empty</phrase><phrase role="special">())</phrase>
                      <phrase role="identifier">b</phrase> <phrase role="special">=</phrase>
                      <phrase role="identifier">b</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">();</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      linear
                    </para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">++</phrase><phrase role="identifier">f</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">b</phrase> <phrase role="special">=</phrase>
                      <phrase role="special">(++</phrase><phrase role="identifier">b</phrase><phrase role="special">).</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      constant
                    </para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">--</phrase><phrase role="identifier">f</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">b</phrase> <phrase role="special">=</phrase>
                      <phrase role="special">--</phrase><phrase role="identifier">b</phrase><phrase role="special">.</phrase><phrase role="identifier">parent</phrase><phrase role="special">();</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      as <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">b</phrase><phrase role="special">.</phrase><phrase role="identifier">parent</phrase><phrase role="special">()</phrase></computeroutput>
                    </para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">!</phrase><phrase role="identifier">f</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">while</phrase> <phrase role="special">((!</phrase><phrase role="identifier">b</phrase><phrase role="special">).</phrase><phrase role="identifier">parity</phrase><phrase role="special">()</phrase>
                      <phrase role="special">==</phrase> <phrase role="number">1</phrase><phrase role="special">);</phrase> <phrase role="identifier">b</phrase>
                      <phrase role="special">=</phrase> <phrase role="special">(!</phrase><phrase role="identifier">b</phrase><phrase role="special">).</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      linear
                    </para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.foresttree.cons">
          <title><link linkend="tree.tree.adaptors.foresttree.cons"><literal moreinfo="none">forest_tree</literal>
          constructors, copy, and assignment <phrase role="std_section_label">[foresttree.cons]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">explicit</phrase> <phrase role="identifier">forest_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">forest_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
<phrase role="identifier">forest_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> The constructor <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase>
            <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase>
            <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
            <phrase role="identifier">vector</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">)</phrase></computeroutput> makes only <literal moreinfo="none">N</literal> calls
            to the copy constructor of <literal moreinfo="none">T</literal> (where <literal moreinfo="none">N</literal>
            is the number of elements in <literal moreinfo="none">subtree</literal>) and no reallocations
            if the cursor <literal moreinfo="none">subtree</literal> is of (either descending or
            ascending) forward, bidirectional, or random access categories. It does
            at most <literal moreinfo="none">2N</literal> calls to the copy constructor of <literal moreinfo="none">T</literal>
            and <literal moreinfo="none">logN</literal> reallocations if they are just cursors, since
            it is impossible to determine the size of <literal moreinfo="none">subtree</literal>
            and then do copying.
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Effects:</emphasis>
          </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase> <phrase role="identifier">i</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">root</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase> <phrase role="special">*</phrase><phrase role="identifier">i</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.foresttree.cursors">
          <title><link linkend="tree.tree.adaptors.foresttree.cursors"><literal moreinfo="none">forest_tree</literal>
          cursors <phrase role="std_section_label">[foresttree.cursors]</phrase></link></title>
        </section>
        <section id="tree.tree.adaptors.foresttree.modifiers">
          <title><link linkend="tree.tree.adaptors.foresttree.modifiers"><literal moreinfo="none">forest_tree</literal>
          modifiers <phrase role="std_section_label">[foresttree.modifiers]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
<phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Notes:</emphasis> Does not affect the validity of cursors and
            references.
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Notes:</emphasis> Invalidates only the cursors and references
            to the erased elements.
          </para>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.foresttree.special">
          <title><link linkend="tree.tree.adaptors.foresttree.special"><literal moreinfo="none">forest_tree</literal>
          specialized algorithms <phrase role="std_section_label">[foresttree.special]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
            <phrase role="identifier">forest_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Effects:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">);</phrase></computeroutput>
          </para>
          </simplesect>
        </section>
      </section>
      <section id="tree.tree.adaptors.multiwaytree">
        <title><link linkend="tree.tree.adaptors.multiwaytree">Class template <literal moreinfo="none">multiway_tree</literal>
        <phrase role="std_section_label">[multiwaytree]</phrase></link></title>
        <para>
          A <literal moreinfo="none">multiway_tree</literal> is a kind of mutable multiway hierarchy
          that is instantiated with a mutable plain hierarchy whose value type in
          turn is a container holding elements of <literal moreinfo="none">multiway_tree</literal>'s
          <literal moreinfo="none">value_type</literal>.
        </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">nary_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">class</phrase> <phrase role="identifier">multiway_tree</phrase>
  <phrase role="special">{</phrase>
  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Hierarchy</phrase>                                     <phrase role="identifier">hierarchy_type</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
    <phrase role="identifier">hierarchy_type</phrase> <phrase role="identifier">h</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="comment">// types:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">T</phrase>                                             <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">pointer</phrase>              <phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_pointer</phrase>        <phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">reference</phrase>            <phrase role="identifier">reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_reference</phrase>      <phrase role="identifier">const_reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">size_type</phrase>            <phrase role="identifier">size_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">difference_type</phrase>      <phrase role="identifier">difference_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">U</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">rebind</phrase> <phrase role="special">{</phrase>
      <phrase role="keyword">typedef</phrase> <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">U</phrase><phrase role="special">,</phrase>
        <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="keyword">template</phrase> <phrase role="identifier">rebind</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase> <phrase role="special">&gt;::</phrase><phrase role="identifier">other</phrase> <phrase role="special">&gt;</phrase>
          <phrase role="identifier">other</phrase><phrase role="special">;</phrase>
    <phrase role="special">};</phrase>

    <phrase role="comment">// construct/copy/destroy:</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">multiway_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">multiway_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">multiway_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="special">~</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase>
      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>

    <phrase role="comment">// cursors:</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">root</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">croot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase> <phrase role="keyword">const</phrase><phrase role="special">();</phrase>

    <phrase role="comment">// capacity:</phrase>
    <phrase role="keyword">bool</phrase>      <phrase role="identifier">empty</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">max_size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>

    <phrase role="comment">// modifiers:</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">rotate</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">p</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
  <phrase role="special">};</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="comment">// specialized algorithms:</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
        <para>
          Types <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase></computeroutput>
          and <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase></computeroutput>
          are required to be random access cursors.
        </para>
        <section id="tree.tree.adaptors.multiwaytree.types">
          <title><link linkend="tree.tree.adaptors.multiwaytree.types"><literal moreinfo="none">multiway_tree</literal>
          types <phrase role="std_section_label">[multiwaytree.types]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            Both <literal moreinfo="none">cursor</literal> and <literal moreinfo="none">const_cursor</literal> have
            to fulfill the plain cursor requirements ([cursor.flavors]). If <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase></computeroutput>
            is an ascending random access cursor, <literal moreinfo="none">cursor</literal> and
            <literal moreinfo="none">const_cursor</literal> are also ascending random access cursors
            ([ascending.random.access.cursors]); otherwise, they are descending random
            access cursor ([descending.random.access.cursors]).
          </para>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Notes:</emphasis> The operational semantics of the adaptor
            cursor are as follows in terms of the adaptee cursor (only valid if present
            in the adaptor cursor's category; only given for mutable versions of
            expressions, const ones as according; expressions missing from the list
            mean operational semantics and complexity are for <literal moreinfo="none">m</literal>
            as they are for <literal moreinfo="none">n</literal>):
          </para>
          <table frame="all" id="tree.tree.adaptors.multiwaytree.types.table7">
            <title>Multiway/nary tree cursor operational semantics correspondences</title>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>
                    <para>
                      adaptor cursor <literal moreinfo="none">m</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      adaptee cursor <literal moreinfo="none">n</literal>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      complexity
                    </para>
                  </entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*</phrase><phrase role="identifier">m</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*((</phrase><phrase role="identifier">p</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">begin</phrase><phrase role="special">())[</phrase><phrase role="identifier">b</phrase><phrase role="special">.</phrase><phrase role="identifier">parity</phrase><phrase role="special">()])</phrase></computeroutput>
                    </para>
                  </entry>
                  <entry>
                    <para>
                      constant
                    </para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.multiwaytree.cons">
          <title><link linkend="tree.tree.adaptors.multiwaytree.cons"><literal moreinfo="none">multiway_tree</literal>
          constructors, copy, and assignment <phrase role="std_section_label">[multiwaytree.cons]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">explicit</phrase> <phrase role="identifier">multiway_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">multiway_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
<phrase role="identifier">multiway_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> The constructor <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase>
            <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase>
            <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
            <phrase role="identifier">vector</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">)</phrase></computeroutput> makes only <literal moreinfo="none">N</literal> calls
            to the copy constructor of <literal moreinfo="none">T</literal> (where <literal moreinfo="none">N</literal>
            is the number of elements in <literal moreinfo="none">subtree</literal>) and no reallocations
            if the cursor <literal moreinfo="none">subtree</literal> is of (either descending or
            ascending) forward, bidirectional, or random access categories. It does
            at most <literal moreinfo="none">2N</literal> calls to the copy constructor of <literal moreinfo="none">T</literal>
            and <literal moreinfo="none">logN</literal> reallocations if they are just cursors, since
            it is impossible to determine the size of <literal moreinfo="none">subtree</literal>
            and then do copying.
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Effects:</emphasis>
          </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
<phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase> <phrase role="identifier">i</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">root</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase> <phrase role="special">*</phrase><phrase role="identifier">i</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.multiwaytree.cursors">
          <title><link linkend="tree.tree.adaptors.multiwaytree.cursors"><literal moreinfo="none">multiway_tree</literal>
          cursors <phrase role="std_section_label">[multiwaytree.cursors]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> constant
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">();</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Returns:</emphasis> A cursor to the <literal moreinfo="none">multiway_tree</literal>'s
            first element in inorder (see [order.iterators], §4).
          </para>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> constant.
          </para>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.multiwaytree.capacity">
          <title><link linkend="tree.tree.adaptors.multiwaytree.capacity"><literal moreinfo="none">multiway_tree</literal>
          capacity <phrase role="std_section_label">[multiwaytree.capacity]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">size_type</phrase> <phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Returns:</emphasis> The total number of child elements that
            the cursor <literal moreinfo="none">position</literal> can hold without requiring reallocation.
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Effects:</emphasis> A directive that informs an <literal moreinfo="none">multiway_tree</literal>
            of a planned change in a given cursor's size, so that it can manage the
            storage allocation accordingly. After <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase></computeroutput>, <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">)</phrase></computeroutput> is greater or equal to the <literal moreinfo="none">size_type</literal>
            argument <literal moreinfo="none">n</literal> of reserve if reallocation happens; and
            equal to the previous value of <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">position</phrase><phrase role="special">)</phrase></computeroutput> otherwise. Reallocation happens at this
            point if and only if the current capacity is less than the <literal moreinfo="none">size_type</literal>
            argument <literal moreinfo="none">n</literal> of <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">()</phrase></computeroutput>.
          </para>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> It does not change the size of the
            <literal moreinfo="none">multiway_tree</literal> and takes at most linear time in <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()</phrase></computeroutput>.
          </para>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Notes:</emphasis> Reallocation invalidates all the references,
            pointers, and cursors referring to the child elements of <literal moreinfo="none">position</literal>.
            It is guaranteed that no reallocation takes place during insertions to
            <literal moreinfo="none">position</literal> that happen after a call to <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">()</phrase></computeroutput>
            until the time when an insertion would make <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">position</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()</phrase></computeroutput> greater than the size specified in
            the most recent call to <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">reserve</phrase><phrase role="special">()</phrase></computeroutput>.
          </para>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.multiwaytree.modifiers">
          <title><link linkend="tree.tree.adaptors.multiwaytree.modifiers"><literal moreinfo="none">multiway_tree</literal>
          modifiers <phrase role="std_section_label">[multiwaytree.modifiers]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
<phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert_above</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Notes:</emphasis> Does not affect the validity of cursors and
            references.
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Notes:</emphasis> Invalidates only the cursors and references
            to the erased elements.
          </para>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.multiwaytree.special">
          <title><link linkend="tree.tree.adaptors.multiwaytree.special"><literal moreinfo="none">multiway_tree</literal>
          specialized algorithms <phrase role="std_section_label">[multiwaytree.special]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
              <phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Effects:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">);</phrase></computeroutput>
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">inorder_first</phrase><phrase role="special">())</phrase></computeroutput>.
          </para>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> constant
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">multiway_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Alloc</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">inorder_cfirst</phrase><phrase role="special">())</phrase></computeroutput>.
          </para>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> constant
          </para>
          </simplesect>
        </section>
      </section>
      <section id="tree.tree.adaptors.augment">
        <title><link linkend="tree.tree.adaptors.augment">Augmenting hierarchy adaptors
        <phrase role="std_section_label">[hierarchy.augment]</phrase></link></title>
        <para>
          An augmenting hierarchy "augments" a mutable multiway hierarchy
          which it is given as a template parameter by associating additional information
          with its elements and modeling a mutable multiway hierarchy in turn. This
          additional information is not directly exposed, but only readable via certain
          member functions of the augmentor; it is updated internally in order to
          adapt to structural or content-wise changes in the hierarchy. The library
          provides one augmenting hierarchy adaptor template class: <literal moreinfo="none">rank_tree</literal>,
          found in header <literal moreinfo="none">&lt;augment&gt;</literal>.
        </para>
        <section id="tree.tree.adaptors.augment.ranktree">
          <title><link linkend="tree.tree.adaptors.augment.ranktree">Class template
          <literal moreinfo="none">rank_tree</literal> <phrase role="std_section_label">[ranktree]</phrase></link></title>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">class</phrase> <phrase role="identifier">rank_tree</phrase>
  <phrase role="special">{</phrase>
  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Hierarchy</phrase>                                     <phrase role="identifier">hierarchy_type</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
    <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="keyword">template</phrase> <phrase role="identifier">rebind</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase><phrase role="identifier">size_t</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;::</phrase><phrase role="identifier">other</phrase> <phrase role="identifier">h</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="comment">// types:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">T</phrase>                                             <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">implementation</phrase> <phrase role="identifier">defined</phrase>                        <phrase role="identifier">const_cursor</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">pointer</phrase>              <phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_pointer</phrase>        <phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">reference</phrase>            <phrase role="identifier">reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_reference</phrase>      <phrase role="identifier">const_reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">size_type</phrase>            <phrase role="identifier">size_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">difference_type</phrase>      <phrase role="identifier">difference_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">U</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">rebind</phrase> <phrase role="special">{</phrase>
      <phrase role="keyword">typedef</phrase> <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">U</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="keyword">template</phrase> <phrase role="identifier">rebind</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">other</phrase> <phrase role="special">&gt;</phrase>
        <phrase role="identifier">other</phrase><phrase role="special">;</phrase>
    <phrase role="special">};</phrase>

    <phrase role="comment">// construct/copy/destroy:</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">rank_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">rank_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">rank_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="special">~</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase>
      <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>

    <phrase role="comment">// cursors:</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">root</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">croot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">shoot</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">cshoot</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">inorder_first</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">inorder_cfirst</phrase> <phrase role="keyword">const</phrase><phrase role="special">();</phrase>

    <phrase role="identifier">cursor</phrase>        <phrase role="identifier">rank</phrase><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">rank</phrase><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// capacity:</phrase>
    <phrase role="keyword">bool</phrase>      <phrase role="identifier">empty</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">max_size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">capacity</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">reserve</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>

    <phrase role="comment">// modifiers:</phrase>
    <phrase role="identifier">cursor</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputCursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cursor</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputCursor</phrase> <phrase role="identifier">subtree</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">rotate</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">(</phrase><phrase role="identifier">cursor</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
  <phrase role="special">};</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hier</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="comment">// specialized algorithms:</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">inorder</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">rank_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
          <para>
            Each function listed in the public interface of <literal moreinfo="none">rank_tree</literal>
            as above calls a function of the same name for its adaptee object <literal moreinfo="none">h</literal>,
            plus possibly other operations with guaranteed logarithmic time complexity
            in total. This means that operational semantics and time complexities
            are as specified by the <literal moreinfo="none">hierarchy_type</literal>; and that a
            function can only be called if a function of the same name is present
            in the public interface of <literal moreinfo="none">hierarchy_type</literal>. (The only
            exception to the above stated are the functions <literal moreinfo="none">rank()</literal>,
            which are newly introduced.)
          </para>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">cursor</phrase>        <phrase role="identifier">rank</phrase><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
<phrase role="identifier">const_cursor</phrase>  <phrase role="identifier">rank</phrase><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Returns:</emphasis> A cursor (or <literal moreinfo="none">const_cursor</literal>)
            to the <literal moreinfo="none">n=th element of the hierarchy in inorder, counting from
            =inorder_first()</literal>.
          </para>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> logarithmic in <literal moreinfo="none">size()</literal>.
          </para>
          </simplesect>
        </section>
      </section>
      <section id="tree.tree.adaptors.balance">
        <title><link linkend="tree.tree.adaptors.balance">Balancing hierarchy adaptors
        <phrase role="std_section_label">[hierarchy.balance]</phrase></link></title>
        <note>
          <para>
            These do not model AssociativeContainer yet but Sequence as they permit
            insertion in arbitrary positions. (This way, they are not required to
            take care of extracting, sorting and searching.)
          </para>
        </note>
        <para>
          A balancing hierarchy adaptor uses some kind of balancing method in order
          to guarantee logarithmic time complexity for many important operations
          while keeping the inorder of the adaptee hierarchy as its invariant.
        </para>
        <para>
          A balancing hierarchy adaptor satisfies all of the requirements of a container
          ([lib.container.requirements]), of a sequence ([lib.sequence.reqmts]),
          with the exception that its <literal moreinfo="none">erase()</literal> member functions
          return <literal moreinfo="none">void</literal>, and most of the optional sequence requirements,
          except for the =operator[]= and <literal moreinfo="none">at</literal> member functions,
          which are not provided. If the adaptee hierarchy supports at least descending
          bidirectional cursors, it also satisfies the requirements of a reversible
          container. Descriptions are provided here only for operations on balancing
          hierarchy adaptors that are not described in one of these tables or for
          operations where there is additional semantic information.
        </para>
        <para>
          The library provides four balancing hierarchy adaptor template classes
          which take a mutable multiway template parameter that provides a <literal moreinfo="none">rotate()</literal>
          operation and whose <literal moreinfo="none">cursor</literal> and <literal moreinfo="none">const_cursor</literal>
          types satisfy the requirements of a binary tree cursor ([bintree.types],
          §1 and §2): <literal moreinfo="none">avl_tree</literal>, <literal moreinfo="none">red_black_tree</literal>,
          <literal moreinfo="none">splay_tree</literal>, and <literal moreinfo="none">treap</literal>. Furthermore,
          two balancing hierarchy adaptor template classes that take a mutable multiway
          tree template parameter are provided: <literal moreinfo="none">b_tree</literal> and <literal moreinfo="none">b_star_tree</literal>.
          All balancing adaptors and corresponding free functions are found in header
          <literal moreinfo="none">&lt;balance&gt;</literal>.
        </para>
        <para>
          In the following, only the template class <literal moreinfo="none">avl_tree</literal> and
          related operators are shown. Note that also <literal moreinfo="none">red_black_tree</literal>,
          <literal moreinfo="none">splay_tree</literal>, and <literal moreinfo="none">treap</literal> must be present
          and have identical interfaces (with all occurrences of <literal moreinfo="none">avl_tree</literal>
          replaced accordingly). The same holds true for <literal moreinfo="none">b_tree</literal>
          and <literal moreinfo="none">b_star_tree</literal>, as well, except that the standard value
          for the template parameter reads <literal moreinfo="none">multiway_tree&lt;T&gt;</literal>
          (instead of <literal moreinfo="none">binary_tree&lt;T&gt;</literal>) in their case.
        </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase> <phrase role="special">=</phrase> <phrase role="identifier">binary_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">class</phrase> <phrase role="identifier">avl_tree</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Hierarchy</phrase>                                     <phrase role="identifier">hierarchy_type</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
    <phrase role="identifier">hierarchy_type</phrase> <phrase role="identifier">h</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="comment">// types:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">value_type</phrase>           <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">pointer</phrase>              <phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_pointer</phrase>        <phrase role="identifier">const_pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">reference</phrase>            <phrase role="identifier">reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_reference</phrase>      <phrase role="identifier">const_reference</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">size_type</phrase>            <phrase role="identifier">size_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">::</phrase><phrase role="identifier">difference_type</phrase>      <phrase role="identifier">difference_type</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">iterator</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <emphasis>implementation-defined</emphasis>                        <phrase role="identifier">const_iterator</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">typedef</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">reverse_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&gt;</phrase>               <phrase role="identifier">reverse_iterator</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">reverse_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">const_iterator</phrase><phrase role="special">&gt;</phrase>         <phrase role="identifier">const_reverse_iterator</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// construct/copy/destroy:</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">avl_tree</phrase><phrase role="special">(</phrase><phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">avl_tree</phrase><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">value</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">(),</phrase>
      <phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">avl_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
        <phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
    <phrase role="identifier">avl_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="special">~</phrase><phrase role="identifier">avl_tree</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase>
      <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Size</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">Size</phrase> <phrase role="identifier">n</phrase><phrase role="special">,</phrase> <phrase role="identifier">T</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">t</phrase> <phrase role="special">=</phrase> <phrase role="identifier">T</phrase><phrase role="special">());</phrase>

    <phrase role="comment">// iterators:</phrase>
    <phrase role="identifier">iterator</phrase>                <phrase role="identifier">begin</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_iterator</phrase>          <phrase role="identifier">cbegin</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">iterator</phrase>                <phrase role="identifier">end</phrase><phrase role="special">()</phrase>             <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">shoot</phrase><phrase role="special">());</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">const_iterator</phrase>          <phrase role="identifier">cend</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase>      <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">const_iterator</phrase><phrase role="special">(</phrase><phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">cshoot</phrase><phrase role="special">());</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">reverse_iterator</phrase>        <phrase role="identifier">rbegin</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_reverse_iterator</phrase>  <phrase role="identifier">crbegin</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">reverse_iterator</phrase>        <phrase role="identifier">rend</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_reverse_iterator</phrase>  <phrase role="identifier">crend</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// capacity:</phrase>
    <phrase role="keyword">bool</phrase>      <phrase role="identifier">empty</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">empty</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase>  <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">size_type</phrase> <phrase role="identifier">max_size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">resize</phrase><phrase role="special">(</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">sz</phrase><phrase role="special">,</phrase> <phrase role="identifier">T</phrase> <phrase role="identifier">c</phrase> <phrase role="special">=</phrase> <phrase role="identifier">T</phrase><phrase role="special">());</phrase>

    <phrase role="comment">// element access:</phrase>
    <phrase role="identifier">reference</phrase>       <phrase role="identifier">front</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_reference</phrase> <phrase role="identifier">front</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">reference</phrase>       <phrase role="identifier">back</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">const_reference</phrase> <phrase role="identifier">back</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// map operations:</phrase>
    <phrase role="identifier">iterator</phrase> <phrase role="identifier">find</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
      <phrase role="identifier">const_iterator</phrase> <phrase role="identifier">find</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">iterator</phrase> <phrase role="identifier">find</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">);</phrase>
        <phrase role="identifier">const_iterator</phrase> <phrase role="identifier">find</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="identifier">size_type</phrase> <phrase role="identifier">count</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">size_type</phrase> <phrase role="identifier">count</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="identifier">iterator</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">const_iterator</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">iterator</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">const_iterator</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="identifier">iterator</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">const_iterator</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">iterator</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">const_iterator</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">iterator</phrase><phrase role="special">,</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">equal_range</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">const_iterator</phrase><phrase role="special">,</phrase><phrase role="identifier">const_iterator</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">equal_range</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">iterator</phrase><phrase role="special">,</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&gt;</phrase>
        <phrase role="identifier">equal_range</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">const_iterator</phrase><phrase role="special">,</phrase><phrase role="identifier">const_iterator</phrase><phrase role="special">&gt;</phrase>
        <phrase role="identifier">equal_range</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="comment">// modifiers:</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">push_front</phrase><phrase role="special">(</phrase><phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">iterator</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">iterator</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">iterator</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
      <phrase role="keyword">void</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">iterator</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">pop_front</phrase><phrase role="special">();</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">pop_back</phrase><phrase role="special">();</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">erase</phrase><phrase role="special">(</phrase><phrase role="identifier">iterator</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">erase</phrase><phrase role="special">(</phrase><phrase role="identifier">iterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase> <phrase role="identifier">iterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Tp</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;);</phrase>
    <phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">clear</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
  <phrase role="special">};</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>  <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">&lt;</phrase> <phrase role="special">(</phrase>  <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>  <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">&gt;</phrase> <phrase role="special">(</phrase>  <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">&gt;=(</phrase>  <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">&lt;=(</phrase>  <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="comment">// specialized algorithms:</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
                <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
        <section id="tree.tree.adaptors.balance.cons">
          <title><link linkend="tree.tree.adaptors.balance.cons">Balancing adaptor
          constructors, copy, and assigment <phrase role="std_section_label">[balance.cons]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">explicit</phrase> <phrase role="identifier">avl_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">avl_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">,</phrase>
    <phrase role="identifier">hierarchy_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hierarchy_type</phrase><phrase role="special">());</phrase>
<phrase role="identifier">avl_tree</phrase> <phrase role="special">(</phrase><phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Effects:</emphasis> constructs a balanced tree equal to the
            range [<literal moreinfo="none">first</literal>, <literal moreinfo="none">last</literal>).
          </para>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> Linear.
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Effects:</emphasis>
          </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
<phrase role="keyword">while</phrase><phrase role="special">(</phrase><phrase role="identifier">first</phrase><phrase role="special">++</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">last</phrase><phrase role="special">)</phrase>
  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase> <phrase role="special">*</phrase><phrase role="identifier">first</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.balance.map">
          <title><link linkend="tree.tree.adaptors.balance.map">Balancing adaptor
          map operations <phrase role="std_section_label">[balance.map]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">iterator</phrase> <phrase role="identifier">find</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
<phrase role="identifier">const_iterator</phrase> <phrase role="identifier">find</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">iterator</phrase> <phrase role="identifier">find</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">);</phrase>
<phrase role="identifier">const_iterator</phrase> <phrase role="identifier">find</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

<phrase role="identifier">size_type</phrase> <phrase role="identifier">count</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">size_type</phrase> <phrase role="identifier">count</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

<phrase role="identifier">iterator</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
<phrase role="identifier">const_iterator</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">iterator</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">);</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">const_iterator</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

<phrase role="identifier">iterator</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
<phrase role="identifier">const_iterator</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">iterator</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">);</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">const_iterator</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

<phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">iterator</phrase><phrase role="special">,</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">equal_range</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
<phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">const_iterator</phrase><phrase role="special">,</phrase><phrase role="identifier">const_iterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">equal_range</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">iterator</phrase><phrase role="special">,</phrase><phrase role="identifier">iterator</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">equal_range</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">);</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cmp</phrase><phrase role="special">&gt;</phrase>
  <phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">const_iterator</phrase><phrase role="special">,</phrase><phrase role="identifier">const_iterator</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">equal_range</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">Cmp</phrase> <phrase role="identifier">cmp</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Notes:</emphasis> The <literal moreinfo="none">find</literal>, <literal moreinfo="none">lower_bound</literal>,
            <literal moreinfo="none">upper_bound</literal> and <literal moreinfo="none">equal_range</literal> member
            functions each have four versions, differing in whether they return an
            <literal moreinfo="none">iterator</literal> or a <literal moreinfo="none">const_iterator</literal>, and
            if they take a <literal moreinfo="none">cmp</literal> function object argument or not
            (<literal moreinfo="none">count</literal> comes only in the latter two variants, as it
            returns a <literal moreinfo="none">size_type</literal>, not an iterator). In each case
            the behavior of the four (two) functions is in principle identical.
          </para>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> logarithmic (with the exception of
            <literal moreinfo="none">count</literal>, which is <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">log</phrase><phrase role="special">(</phrase><phrase role="identifier">size</phrase><phrase role="special">())</phrase> <phrase role="special">+</phrase> <phrase role="identifier">count</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">)</phrase></computeroutput>
          </para>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.balance.modifiers">
          <title><link linkend="tree.tree.adaptors.balance.modifiers">Balancing adaptor
          modifiers <phrase role="std_section_label">[balance.modifiers]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase>      <phrase role="identifier">push_front</phrase><phrase role="special">(</phrase><phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
<phrase role="keyword">void</phrase>      <phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
<phrase role="identifier">iterator</phrase>  <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">iterator</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">());</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> amortized constant
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase>      <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">iterator</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_type</phrase> <phrase role="identifier">n</phrase><phrase role="special">,</phrase> <phrase role="identifier">value_type</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase>    <phrase role="identifier">insert</phrase><phrase role="special">(</phrase><phrase role="identifier">iterator</phrase> <phrase role="identifier">position</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> linear in the number of elements to
            insert
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase>      <phrase role="identifier">pop_front</phrase><phrase role="special">();</phrase>
<phrase role="keyword">void</phrase>      <phrase role="identifier">pop_back</phrase><phrase role="special">();</phrase>
<phrase role="keyword">void</phrase>      <phrase role="identifier">erase</phrase><phrase role="special">(</phrase><phrase role="identifier">iterator</phrase> <phrase role="identifier">position</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> amortized constant
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase>      <phrase role="identifier">erase</phrase><phrase role="special">(</phrase><phrase role="identifier">iterator</phrase> <phrase role="identifier">first</phrase><phrase role="special">,</phrase> <phrase role="identifier">iterator</phrase> <phrase role="identifier">last</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> <literal moreinfo="none">log(size())+N</literal> where
            <literal moreinfo="none">N</literal> is the distance from <literal moreinfo="none">first</literal> to
            <literal moreinfo="none">last</literal>
          </para>
          </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase>      <phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Complexity:</emphasis> <literal moreinfo="none">log(size())+N</literal>
          </para>
          </simplesect>
        </section>
        <section id="tree.tree.adaptors.balance.special">
          <title><link linkend="tree.tree.adaptors.balance.special">Balancing adaptor
          specialized algorithms <phrase role="std_section_label">[balance.special]</phrase></link></title>
          <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase>  <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
              <phrase role="identifier">avl_tree</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
</programlisting>
          </simplesect> <simplesect role="std_specification">
          <para>
            <emphasis>Effects:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">);</phrase></computeroutput>
          </para>
          </simplesect>
        </section>
      </section>
    </section>
  </section>
  </section> </section> <section role="std_section" id="tree.proposal.iterators" label="24" label-style="no-parent">
<title><link linkend="tree.proposal.iterators">Iterators library
  <phrase role="std_section_label">[iterators]</phrase></link></title> <section role="std_section" id="iterator.synopsis" label="24.3" label-style="no-parent">
<title><link linkend="iterator.synopsis">Headers
  <literal moreinfo="none">&lt;iterator&gt;</literal> synopsis <phrase role="std_section_label">[iterator.synopsis]</phrase></link></title>
  <note>
    <para>
      Insert after section introduced with <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="comment">// 24.6.5,
      range access:</phrase></computeroutput>
    </para>
  </note>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="comment">// 24.7, linear order traversal iterators</phrase>
<phrase role="keyword">namespace</phrase> <phrase role="identifier">preorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
      <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
      <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
      <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
      <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace preorder   </phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">postorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace postorder   </phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
  </section> <section role="std_section" id="cursors" label="24.7" label-style="no-parent">
<title><link linkend="cursors">Cursors <phrase role="std_section_label">[cursors]</phrase></link></title>
  <note>
    <para>
      Add after subclause 24.7, Stream iterators ([stream.iterators]):
    </para>
  </note>
  <para>
    Cursors provide a uniform way of applying algorithms to hierarchical data structures.
    In order to also allow for algorithms relevant when dealing with linear data
    structures, any cursor class is actually a refinement of a corresponding iterator
    class.
  </para>
  <para>
    If exactly one application of the expression <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">i</phrase>
    <phrase role="special">=</phrase> <phrase role="identifier">i</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()</phrase></computeroutput>,
    followed by a finite sequence of applications of the expression <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">++</phrase><phrase role="identifier">j</phrase></computeroutput> makes
    <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">i</phrase> <phrase role="special">==</phrase>
    <phrase role="identifier">j</phrase></computeroutput>, <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">j</phrase></computeroutput>
    is a <emphasis>child</emphasis> (or <emphasis>immediate descendant</emphasis>)
    of <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">i</phrase></computeroutput>, and <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">i</phrase></computeroutput>
    is the <emphasis>parent</emphasis> (or the <emphasis>immediate ancestor</emphasis>)
    of <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">j</phrase></computeroutput>. A cursor <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">j</phrase></computeroutput> is another cursor <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">i</phrase></computeroutput>'s
    descendant if there is a finite sequential combination of applications of either
    of the expressions <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">++</phrase><phrase role="identifier">i</phrase></computeroutput>
    and <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">i</phrase> <phrase role="special">=</phrase>
    <phrase role="identifier">i</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()</phrase></computeroutput> that
    makes <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">i</phrase> <phrase role="special">==</phrase>
    <phrase role="identifier">j</phrase></computeroutput>; <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">i</phrase></computeroutput>
    is then called <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">j</phrase></computeroutput>'s ancestor.
    If two cursors <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">i</phrase></computeroutput> and <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">j</phrase></computeroutput> share at least one common ancestor, they
    refer to the same container. The descending traversal capabilities of a class
    relate to the range of children of a given instance of that class.
  </para>
  <para>
    In addition to a cursor's descending traversal tags, two of them are reused to
    indicate a cursor's ascending traversal abilities, namely <emphasis>forward</emphasis>
    and <emphasis>bidirectional</emphasis> traversal in order to indicate whether
    a given cursor provides traversal to the parent.
  </para>
  <para>
    Apart from cursors that are <emphasis>past-the-end</emphasis> (like their iterator
    counterparts can be), the notion of a cursor <emphasis>on-top</emphasis> is introduced,
    denoting a cursor that is ancestor to all other cursors within a hierarchy; and
    just as for past-the-end ones, the library generally does not assume on-top cursors
    be dereferenceable.
  </para>
  <para>
    A cursor <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">c</phrase></computeroutput> for which <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">c</phrase><phrase role="special">.</phrase><phrase role="identifier">emtpy</phrase><phrase role="special">()</phrase> <phrase role="special">==</phrase> <phrase role="keyword">true</phrase></computeroutput>
    is called a <emphasis>leaf cursor</emphasis>. A leaf cursor's children are never
    assumed to be dereferenceable. A cursor which is either on-top or a descendant
    of an on-top cursor, but in either case not a leaf cursor, nor a descendant of
    a leaf cursor, is called an <emphasis>internal cursor</emphasis>.
  </para>
  <para>
    A cursor, like an iterator, can have a singular value that is not associated
    with any hierarchy, meaning that most expressions are undefined for it, with
    the exception of assignment of a non-singular value to a cursor that holds a
    singular value. The children of a leaf cursor's child are never assumed to be
    non-singular; nor is the parent of an on-top node.
  </para>
  <para>
    Like for iterators, the Standard defines a number of categories of cursors according
    to the operations defined on them: <emphasis>cursor</emphasis>, <emphasis>descending
    cursor</emphasis>, <emphasis>descending forward cursor</emphasis>, <emphasis>descending
    bidirectional cursor</emphasis>, <emphasis>descending random access cursor</emphasis>,
    <emphasis>ascending cursor</emphasis>, <emphasis>ascending forward cursor</emphasis>,
    <emphasis>ascending bidirectional</emphasis> , and <emphasis>ascending random
    access cursor</emphasis>. The cursors of any <emphasis>ascending</emphasis> category
    generally support all the operations of their <emphasis>descending</emphasis>
    counterpart, plus a method to obtain their parent; relations between the <emphasis>forward</emphasis>,
    <emphasis>bidirectional</emphasis> and <emphasis>random access</emphasis> parts
    are as for iterators of those categories.
  </para>
  <para>
    In the following sections <literal moreinfo="none">X</literal> denotes a cursor over values of
    type <literal moreinfo="none">T</literal>, <literal moreinfo="none">a</literal> and <literal moreinfo="none">b</literal> denotes
    an identifier, <literal moreinfo="none">r</literal> denotes a value of <literal moreinfo="none">T&amp;</literal>
    and <literal moreinfo="none">t</literal> denotes a value of type <literal moreinfo="none">T</literal>.
  </para>
  <section id="tree.cursor_requirements">
    <title><link linkend="tree.cursor_requirements">Cursor requirements <phrase role="std_section_label">[cursor.requirements]</phrase></link></title>
    <simplesect role="std_requisite">
    <para>
      A class <literal moreinfo="none">X</literal> satisfies the requirements of a cursor if the
      following expressions are valid, as shown in Table 8, in addition to satisfying
      the requirements of input iterators ([input.iterators]) and output iterators
      ([output.iterators]):
    </para>
    <table frame="all" id="tree.cursor_requirements.table8">
      <title> Cursor requirements (in addition to input and output iterators)</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>
              <para>
                expression
              </para>
            </entry>
            <entry>
              <para>
                return type
              </para>
            </entry>
            <entry>
              <para>
                operational semantics
              </para>
            </entry>
            <entry>
              <para>
                assertion/note <sbr/> pre/post-condition
              </para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">X::value_type</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal moreinfo="none">T</literal>
              </para>
            </entry>
            <entry>
              <para>
                Any non-reference, non-cv-qualified type
              </para>
            </entry>
            <entry>
              <para>
                compile time
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">X::type</literal>
              </para>
            </entry>
            <entry>
              <para>
                Convertible to <literal moreinfo="none">cursor_tag</literal>, <literal moreinfo="none">input_iterator_tag</literal>,
                and <literal moreinfo="none">output_iterator_tag</literal>
              </para>
            </entry>
            <entry>
            </entry>
            <entry>
              <para>
                compile time
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">X::cursor</literal>
              </para>
            </entry>
            <entry>
              <para>
                Convertible to <literal moreinfo="none">X</literal>
              </para>
            </entry>
            <entry>
            </entry>
            <entry>
              <para>
                compile time
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal moreinfo="none">X::const_cursor</literal>
              </para>
            </entry>
            <entry>
              <para>
                Convertible to <literal moreinfo="none">const X</literal>
              </para>
            </entry>
            <entry>
            </entry>
            <entry>
              <para>
                compile time
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    </simplesect>
<section id="tree.cursor_requirements.descending">
      <title><link linkend="tree.cursor_requirements.descending">Descending Cursor
      <phrase role="std_section_label">[descending.cursors]</phrase></link></title>
      <simplesect role="std_requisite">
      <para>
        A class <literal moreinfo="none">X</literal> satisfies the requirements of a descending cursor
        if, in addition to satisfying the requirements for cursors ([cursor.requirements])
        it also conforms to the container requirements ([container.requirements])
        with the exception of the following expressions:
      </para>
      <table frame="all" id="tree.cursor_requirements.descending.table9">
        <title> Container requirements that are not supported</title>
        <tgroup cols="1">
          <thead>
            <row>
              <entry>
                <para>
                  unsupported expression
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">const_iterator</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">reverse_iterator</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">reverse_const_iterator</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">(&amp;</phrase><phrase role="identifier">a</phrase><phrase role="special">)-&gt;~</phrase><phrase role="identifier">X</phrase><phrase role="special">();</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase><phrase role="special">(</phrase><phrase role="identifier">a</phrase><phrase role="special">);</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase> <phrase role="identifier">u</phrase><phrase role="special">(</phrase><phrase role="identifier">a</phrase><phrase role="special">);</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase> <phrase role="identifier">u</phrase>
                  <phrase role="special">=</phrase> <phrase role="identifier">a</phrase><phrase role="special">;</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">()</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">rbegin</phrase><phrase role="special">()</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">rend</phrase><phrase role="special">()</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase> <phrase role="special">==</phrase>
                  <phrase role="identifier">b</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase> <phrase role="special">!=</phrase>
                  <phrase role="identifier">b</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">swap</phrase><phrase role="special">(</phrase><phrase role="identifier">b</phrase><phrase role="special">)</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">r</phrase> <phrase role="special">=</phrase>
                  <phrase role="identifier">a</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase> <phrase role="special">&lt;</phrase>
                  <phrase role="identifier">b</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase> <phrase role="special">&gt;</phrase>
                  <phrase role="identifier">b</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase> <phrase role="special">&lt;=</phrase>
                  <phrase role="identifier">b</phrase></computeroutput>
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase> <phrase role="special">&gt;=</phrase>
                  <phrase role="identifier">b</phrase></computeroutput>
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
        Notes: The expressions <literal moreinfo="none">a.begin()</literal> and <literal moreinfo="none">a.end()</literal>
        are, as shown in Table 9, replaced with equivalent expressions for cursors.
      </para>
      </simplesect> <simplesect role="std_requisite">
      <para>
        Additionally, for a descending cursor, the following expression are valid,
        as shown in Table 10:
      </para>
      <table frame="all" id="tree.cursor_requirements.descending.table10">
        <title> Descending cursor requirements (in addition to cursor)</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>
                <para>
                  expression
                </para>
              </entry>
              <entry>
                <para>
                  return type
                </para>
              </entry>
              <entry>
                <para>
                  operational semantics
                </para>
              </entry>
              <entry>
                <para>
                  assertion/note <sbr/> pre/post-condition
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">X::type</literal>
                </para>
              </entry>
              <entry>
                <para>
                  Convertible to <literal moreinfo="none">descending_cursor_tag</literal>
                </para>
              </entry>
              <entry>
              </entry>
              <entry>
                <para>
                  compile time
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.begin()</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">cursor</literal> or <literal moreinfo="none">const_cursor</literal> for
                  constant <literal moreinfo="none">a</literal>
                </para>
              </entry>
              <entry>
                <para>
                  pre: <literal moreinfo="none">a</literal> is non-leaf.
                </para>
              </entry>
              <entry>
                <para>
                  constant
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.end()</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">cursor</literal> or <literal moreinfo="none">const_cursor</literal> for
                  constant <literal moreinfo="none">a</literal>
                </para>
              </entry>
              <entry>
                <para>
                  pre: <literal moreinfo="none">a</literal> is non-leaf.
                </para>
              </entry>
              <entry>
                <para>
                  constant
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.cbegin()</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">const_cursor</literal>
                </para>
              </entry>
              <entry>
                <para>
                  pre: <literal moreinfo="none">a</literal> is non-leaf.
                </para>
              </entry>
              <entry>
                <para>
                  constant
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.cend()</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">const_cursor</literal>
                </para>
              </entry>
              <entry>
                <para>
                  pre: <literal moreinfo="none">a</literal> is non-leaf.
                </para>
              </entry>
              <entry>
                <para>
                  constant
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">a.parity()</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">size_type</literal>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">std::distance(b.begin(), a)</literal> if <literal moreinfo="none">b</literal>
                  is <literal moreinfo="none">a</literal>'s parent. <sbr/> pre: <literal moreinfo="none">a</literal>
                  is non-on-top.
                </para>
              </entry>
              <entry>
                <para>
                  Linear in <literal moreinfo="none">b.size()</literal>
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      </simplesect>
    </section>
    <section id="tree.cursor_requirements.descending_forward">
      <title><link linkend="tree.cursor_requirements.descending_forward">Descending
      Forward Cursor <phrase role="std_section_label">[descending.forward.cursors]</phrase></link></title>
      <para>
        A class type <literal moreinfo="none">X</literal> satisfies the requirements of a descending
        forward cursor if the following expressions are valid, as shown in Table
        11, in addition to the requirements of descending cursors ([descending.cursors])
        and forward iterators ([forward.iterators]):
      </para>
      <table frame="all" id="tree.cursor_requirements.descending_forward.table11">
        <title> Descending forward cursor requirements (in addition to descending
        cursors and forward iterators)</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>
                <para>
                  expression
                </para>
              </entry>
              <entry>
                <para>
                  return type
                </para>
              </entry>
              <entry>
                <para>
                  operational semantics
                </para>
              </entry>
              <entry>
                <para>
                  assertion/note <sbr/> pre/post-condition
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">X::type</literal>
                </para>
              </entry>
              <entry>
                <para>
                  Convertible to <literal moreinfo="none">descending_forward_cursor_tag</literal>
                  and <literal moreinfo="none">forward_iterator_tag</literal>
                </para>
              </entry>
              <entry>
              </entry>
              <entry>
                <para>
                  compile time
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="tree.cursor_requirements.descending_bidirectional">
      <title><link linkend="tree.cursor_requirements.descending_bidirectional">Descending
      Bidirectional Cursor <phrase role="std_section_label">[descending.bidirectional.cursors]</phrase></link></title>
      <para>
        A class type <literal moreinfo="none">X</literal> satisfies the requirements of a descending
        bidirectional cursor if the following expressions are valid, as shown in
        Table 12, in addition to satisfying the requirements for descending forward
        cursors ([descending.forward.cursors]) and bidirectional iterators ([bidirectional.iterators]):
      </para>
      <table frame="all" id="tree.cursor_requirements.descending_bidirectional.table12">
        <title> Descending bidirectional cursor requirements (in addition to forward
        descending cursors and bidirectional iterators)</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>
                <para>
                  expression
                </para>
              </entry>
              <entry>
                <para>
                  return type
                </para>
              </entry>
              <entry>
                <para>
                  operational semantics
                </para>
              </entry>
              <entry>
                <para>
                  assertion/note <sbr/> pre/post-condition
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">type</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  Convertible to <literal moreinfo="none">descending_bidirectional_cursor_tag</literal>
                  and <literal moreinfo="none">bidirectional_iterator_tag</literal>
                </para>
              </entry>
              <entry>
              </entry>
              <entry>
                <para>
                  compile time
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <note>
        <para>
          rbegin() and rend() do not seem very useful for multiway trees, as they
          hide end() and its possible children. Are different semantics or maybe
          having rend() stand in for end() sensible solutions? Or just ignore this
          aspect?
        </para>
      </note>
    </section>
    <section id="tree.cursor_requirements.descending_random_access">
      <title><link linkend="tree.cursor_requirements.descending_random_access">Descending
      Random Access Cursor <phrase role="std_section_label">[descending.random.access.cursors]</phrase></link></title>
      <para>
        A class type <literal moreinfo="none">X</literal> satisfies the requirements of a descending
        random access cursor if the following expressions are valid, as shown in
        Table 13, in addition to satisfying the requirements for descending bidirectional
        cursors ([descending.bidirectional.cursors]) and random access iterators
        ([random.access.iterators]):
      </para>
      <table frame="all" id="tree.cursor_requirements.descending_random_access.table13">
        <title> Descending random access cursor requirements (in addition to descending
        bidirectional cursors and random access iterators)</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>
                <para>
                  expression
                </para>
              </entry>
              <entry>
                <para>
                  return type
                </para>
              </entry>
              <entry>
                <para>
                  operational semantics
                </para>
              </entry>
              <entry>
                <para>
                  assertion/note <sbr/> pre/post-condition
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">type</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  Convertible to <literal moreinfo="none">descending_random_access_cursor_tag</literal>
                  and <literal moreinfo="none">random_access_iterator_tag</literal>
                </para>
              </entry>
              <entry>
              </entry>
              <entry>
                <para>
                  compile time
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="tree.cursor_requirements.ascending">
      <title><link linkend="tree.cursor_requirements.ascending">Ascending Cursor
      <phrase role="std_section_label">[ascending.cursors]</phrase></link></title>
      <simplesect role="std_requisite">
      <para>
        A class type <literal moreinfo="none">X</literal> satisfies the requirements of an ascending
        cursor if the following expressions are valid, as shown in Table 14, in addition
        to satisfying the requirements for descending cursors ([descending.cursors]):
      </para>
      <table frame="all" id="tree.cursor_requirements.ascending.table14">
        <title> Ascending cursor requirements (in addition to descending cursors)</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>
                <para>
                  expression
                </para>
              </entry>
              <entry>
                <para>
                  return type
                </para>
              </entry>
              <entry>
                <para>
                  operational semantics
                </para>
              </entry>
              <entry>
                <para>
                  assertion/note<sbr/> pre/post-condition
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">type</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  Convertible to <literal moreinfo="none">ascending_cursor_tag</literal>
                </para>
              </entry>
              <entry>
              </entry>
              <entry>
                <para>
                  compile time
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">a</phrase><phrase role="special">.</phrase><phrase role="identifier">parent</phrase><phrase role="special">()</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  <literal moreinfo="none">cursor</literal>; <literal moreinfo="none">const_cursor</literal> for
                  a constant <literal moreinfo="none">a</literal>
                </para>
              </entry>
              <entry>
              </entry>
              <entry>
                <para>
                  (Note A)
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">!</phrase><phrase role="identifier">r</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase><phrase role="special">&amp;</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">r</phrase> <phrase role="special">=</phrase>
                  <phrase role="identifier">r</phrase><phrase role="special">.</phrase><phrase role="identifier">parent</phrase><phrase role="special">();</phrase></computeroutput>
                </para>
              </entry>
              <entry>
                <para>
                  pre: <literal moreinfo="none">r</literal> is an internal, non-on-top cursor. <sbr/>
                  post: <literal moreinfo="none">r</literal> is internal. <sbr/> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">r</phrase>
                  <phrase role="special">==</phrase> <phrase role="identifier">s</phrase></computeroutput>
                  and <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">r</phrase></computeroutput> is internal
                  and non-on-top implies <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">!</phrase><phrase role="identifier">r</phrase> <phrase role="special">==</phrase>
                  <phrase role="special">!</phrase><phrase role="identifier">s</phrase></computeroutput>.
                  <sbr/> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&amp;</phrase><phrase role="identifier">r</phrase>
                  <phrase role="special">==</phrase> <phrase role="special">&amp;!</phrase><phrase role="identifier">r</phrase></computeroutput> <sbr/> (Note A)
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
        <emphasis>Notes:</emphasis> Those entries marked "(Note A)" should
        have at worst linear complexity. See the individual hierarchy containers
        for specific complexity.
      </para>
      </simplesect>
    </section>
    <section id="tree.cursor_requirements.ascending_forward">
      <title><link linkend="tree.cursor_requirements.ascending_forward">Ascending
      Forward Cursor <phrase role="std_section_label">[ascending.forward.cursors]</phrase></link></title>
      <para>
        A class type <literal moreinfo="none">X</literal> satisfies the requirements of an ascending
        forward cursor if the following expressions are valid, as shown in Table
        15, in addition to satisfying the requirements for ascending cursors ([ascending.cursors])
        and descending forward cursors ([descending.forward.cursors]):
      </para>
      <table frame="all" id="tree.cursor_requirements.ascending_forward.table15">
        <title> Ascending forward cursor requirements (in addition to ascending cursors
        and descending forward cursors)</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>
                <para>
                  expression
                </para>
              </entry>
              <entry>
                <para>
                  return type
                </para>
              </entry>
              <entry>
                <para>
                  operational semantics
                </para>
              </entry>
              <entry>
                <para>
                  assertion/note<sbr/> pre/post-condition
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">X::type</literal>
                </para>
              </entry>
              <entry>
                <para>
                  Convertible to <literal moreinfo="none">ascending_forward_cursor_tag</literal>
                </para>
              </entry>
              <entry>
              </entry>
              <entry>
                <para>
                  compile time
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="tree.cursor_requirements.ascending_bidirectional">
      <title><link linkend="tree.cursor_requirements.ascending_bidirectional">Ascending
      Bidirectional Cursor <phrase role="std_section_label">[ascending.bidirectional.cursors]</phrase></link></title>
      <para>
        A class type <literal moreinfo="none">X</literal> satisfies the requirements of an ascending
        bidirectional cursor if the following expressions are valid, as shown in
        Table 16, in addition to satisfying the requirements of ascending forward
        cursors ([ascending.forward.cursors]) and descending bidirectional cursors
        ([descending.bidirectional.cursors]):
      </para>
      <table frame="all" id="tree.cursor_requirements.ascending_bidirectional.table16">
        <title> Ascending bidirectional cursor requirements (in addition to ascending
        forward cursors and descending bidirectional cursors)</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>
                <para>
                  expression
                </para>
              </entry>
              <entry>
                <para>
                  return type
                </para>
              </entry>
              <entry>
                <para>
                  operational semantics
                </para>
              </entry>
              <entry>
                <para>
                  assertion/note<sbr/> pre/post-condition
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">X::type</literal>
                </para>
              </entry>
              <entry>
                <para>
                  Convertible to <literal moreinfo="none">ascending_bidirectional_cursor_tag</literal>
                </para>
              </entry>
              <entry>
              </entry>
              <entry>
                <para>
                  compile time
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="tree.cursor_requirements.ascending_random_access">
      <title><link linkend="tree.cursor_requirements.ascending_random_access">Ascending
      Random Access Cursor <phrase role="std_section_label">[ascending.random.access.cursors]</phrase></link></title>
      <para>
        A class type <literal moreinfo="none">X</literal> satisfies the requirements of an ascending
        random access cursor if the following expressions are valid, as shown in
        Table 17, in addition to satisfying the requirements for ascending bidirectional
        cursors ([ascending.bidirectional.cursors]) and descending random access
        cursors ([descending.random.access.cursors]):
      </para>
      <table frame="all" id="tree.cursor_requirements.ascending_random_access.table17">
        <title> Ascending random access cursor requirements (in addition to ascending
        bidirectional cursors and descending random access cursors)</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>
                <para>
                  expression
                </para>
              </entry>
              <entry>
                <para>
                  return type
                </para>
              </entry>
              <entry>
                <para>
                  operational semantics
                </para>
              </entry>
              <entry>
                <para>
                  assertion/note<sbr/> pre/post-condition
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <literal moreinfo="none">X::type</literal>
                </para>
              </entry>
              <entry>
                <para>
                  Convertible to <literal moreinfo="none">ascending_random_access_cursor_tag</literal>
                </para>
              </entry>
              <entry>
              </entry>
              <entry>
                <para>
                  compile time
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>
  <section id="tree.cursor_flavors">
    <title><link linkend="tree.cursor_flavors">Cursor flavors <phrase role="std_section_label">[cursor.flavors]</phrase></link></title>
    <para>
      A cursor that satisfies at least the descending cursor requirements ([descending.cursors])
      can be either a <emphasis>plain cursor</emphasis> or a <emphasis>multiway cursor</emphasis>.
      If the expressions <literal moreinfo="none">a.begin()</literal>, <literal moreinfo="none">a.cbegin()</literal>,
      <literal moreinfo="none">a.end()</literal> and <literal moreinfo="none">a.cend()</literal> are valid for any
      internal cursor <literal moreinfo="none">a</literal> of type <literal moreinfo="none">X</literal>, except for
      past-the-end ones, <literal moreinfo="none">X</literal> satisfies the <emphasis>plain cursor</emphasis>
      requirements. If those expressions are valid for any internal cursor <emphasis>including</emphasis>
      past-the-end ones, <literal moreinfo="none">X</literal> satisfies the <emphasis>multiway cursor</emphasis>
      requirements.
    </para>
  </section>
  <section id="tree.cursor_synopsis">
    <title><link linkend="tree.cursor_synopsis">Header <literal moreinfo="none">&lt;cursor&gt;</literal>
    synopsis <phrase role="std_section_label">[cursor.synopsis]</phrase></link></title>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="comment">// 24.7.4, cursor primitives</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_value</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_reference</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_const_reference</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_pointer</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_difference</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_size</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_category</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Category</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Distance</phrase> <phrase role="special">=</phrase> <phrase role="identifier">ptrdiff_t</phrase><phrase role="special">,</phrase>
            <phrase role="keyword">class</phrase> <phrase role="identifier">Size</phrase> <phrase role="special">=</phrase> <phrase role="identifier">size_t</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Pointer</phrase> <phrase role="special">=</phrase> <phrase role="identifier">T</phrase><phrase role="special">*,</phrase>
            <phrase role="keyword">class</phrase> <phrase role="identifier">Reference</phrase> <phrase role="special">=</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">input_iterator_tag</phrase><phrase role="special">,</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">output_iterator_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">descending_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">cursor_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">descending_forward_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_cursor_tag</phrase><phrase role="special">,</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">forward_iterator_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">descending_bidirectional_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_cursor_tag</phrase><phrase role="special">,</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">bidirectional_iterator_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">descending_random_access_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_cursor_tag</phrase><phrase role="special">,</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">random_access_iterator_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">ascending_cursor_tag</phrase>
        <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_cursor_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">ascending_forward_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_forward_cursor_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">ascending_bidirectional_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_bidirectional_cursor_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">ascending_random_access_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_random_access_cursor_tag</phrase> <phrase role="special">{};</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
  </section>
  <section id="tree.cursor_primitives">
    <title><link linkend="tree.cursor_primitives">Cursor primitives <phrase role="std_section_label">[cursor.primitives]</phrase></link></title>
    <para>
      To simplify the task of defining cursors, the library provides several classes
      and functions:
    </para>
    <section id="tree.cursor_primitives.cursor_traits">
      <title><link linkend="tree.cursor_primitives.cursor_traits">Cursor traits
      <phrase role="std_section_label">[cursor.traits]</phrase></link></title>
      <para>
        The following classes are required to be defined appropriately for a cursor
        of type <literal moreinfo="none">Cursor</literal>:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_value</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">::</phrase><phrase role="identifier">value_type</phrase> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_reference</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">::</phrase><phrase role="identifier">reference</phrase> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_const_reference</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">::</phrase><phrase role="identifier">const_reference</phrase> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_pointer</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">::</phrase><phrase role="identifier">pointer</phrase> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_difference</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">::</phrase><phrase role="identifier">difference_type</phrase> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_size</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">::</phrase><phrase role="identifier">size_type</phrase> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_category</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor_category</phrase> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
    </section>
    <section id="tree.cursor_primitives.cursor_basic">
      <title><link linkend="tree.cursor_primitives.cursor_basic">Basic cursor <phrase role="std_section_label">[cursor.basic]</phrase></link></title>
      <para>
        The <literal moreinfo="none">cursor</literal> template may be used as a base class to ease
        the definition of required types for new cursors.
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Category</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Distance</phrase> <phrase role="special">=</phrase> <phrase role="identifier">ptrdiff_t</phrase><phrase role="special">,</phrase>
            <phrase role="keyword">class</phrase> <phrase role="identifier">Size</phrase> <phrase role="special">=</phrase> <phrase role="identifier">size_t</phrase><phrase role="special">,</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Pointer</phrase> <phrase role="special">=</phrase> <phrase role="identifier">T</phrase><phrase role="special">*,</phrase>
            <phrase role="keyword">class</phrase> <phrase role="identifier">Reference</phrase> <phrase role="special">=</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;&gt;</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor</phrase> <phrase role="special">{</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Category</phrase>  <phrase role="identifier">cursor_category</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">T</phrase>         <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Distance</phrase>  <phrase role="identifier">difference_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Size</phrase>      <phrase role="identifier">size_type</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Pointer</phrase>   <phrase role="identifier">pointer</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Reference</phrase> <phrase role="identifier">reference</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
    </section>
    <section id="tree.cursor_primitives.cursor_tags">
      <title><link linkend="tree.cursor_primitives.cursor_tags">Standard cursor tags
      <phrase role="std_section_label">[cursor.tags]</phrase></link></title>
      <para>
        Cursor tags pick up the notion of iterator tags ([std.iterator.tags]) and
        extend them by adding information about a given cursor class' descending
        or ascending traversal capabilities ([cursor.requirements]). This yields
        the cursor tags <literal moreinfo="none">cursor_tag</literal>, <literal moreinfo="none">descending_cursor_tag</literal>,
        <literal moreinfo="none">descending_forward_cursor_tag</literal>, <literal moreinfo="none">descending_bidirectional_cursor_tag</literal>,
        <literal moreinfo="none">descending_random_access_cursor_tag</literal>, <literal moreinfo="none">ascending_cursor_tag</literal>,
        <literal moreinfo="none">ascending_forward_cursor_tag</literal>, <literal moreinfo="none">ascending_bidirectional_cursor_tag</literal>
        and <literal moreinfo="none">ascending_random_access_cursor_tag</literal>. For every cursor
        of type <literal moreinfo="none">Cursor</literal>, <literal moreinfo="none">cursor_category&lt;Cursor&gt;::type</literal>
        must be defined to be the most specific category tag that describes the cursor's
        behavior.
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">input_iterator_tag</phrase><phrase role="special">,</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">output_iterator_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">descending_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">cursor_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">descending_forward_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_cursor_tag</phrase><phrase role="special">,</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">forward_iterator_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">descending_bidirectional_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_cursor_tag</phrase><phrase role="special">,</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">bidirectional_iterator_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">descending_random_access_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_cursor_tag</phrase><phrase role="special">,</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">random_access_iterator_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">ascending_cursor_tag</phrase>
        <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_cursor_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">ascending_forward_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_forward_cursor_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">ascending_bidirectional_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_bidirectional_cursor_tag</phrase> <phrase role="special">{};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">ascending_random_access_cursor_tag</phrase>
    <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">descending_random_access_cursor_tag</phrase> <phrase role="special">{};</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
    </section>
  </section>
  </section> <section role="std_section" id="order.iterators" label="24.8" label-style="no-parent">
<title><link linkend="order.iterators">Linear order traversal iterators <phrase role="std_section_label">[order.iterators]</phrase></link></title>
  <para>
    For linear traversal of hierarchies, the library offers a number of useful predefined
    iterators, namely for <literal moreinfo="none">preorder</literal>, <literal moreinfo="none">postorder</literal>
    and <literal moreinfo="none">inorder</literal> traversal in namespaces named accordingly.
  </para>
  <para>
    <emphasis>Preorder traversal</emphasis> means that after a given element, first
    the subtree to its left, then the one to its right will be visited.
  </para>
  <para>
    <emphasis>Postorder traversal</emphasis> means that before a given element, first
    the subtree to its left, then the one to its right will be visited.
  </para>
  <para>
    <emphasis>Inorder traversal</emphasis> means that a given element will be visited
    after the subtree to its left and before the one to its right will be visited.
  </para>
  <para>
    For each of the above kinds of traversal order, the library offers a kind of
    order traversal iterator adaptor template class whose template parameter is a
    bidirectional or random access (either ascending or descending) cursor class.
    Increment and decrement operations for these iterator adaptor classes are implemented
    to allow stepwise iteration according to the respective requirements.
  </para>
  <section id="tree.order_iterator">
    <title><link linkend="tree.order_iterator">Class template <literal moreinfo="none">iterator</literal>
    <phrase role="std_section_label">[order.iterator]</phrase></link></title> <simplesect role="std_definition">
    <para>
      In the following, the template class <literal moreinfo="none">iterator</literal> and related
      operators only as in <literal moreinfo="none">namespace</literal> <literal moreinfo="none">preorder</literal>
      are shown. Note that template classes and operators of same name and interface
      must also be present in <literal moreinfo="none">namespace</literal> <literal moreinfo="none">postorder</literal>
      as well as in <literal moreinfo="none">namespace</literal> <literal moreinfo="none">inorder</literal>.
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">std</phrase> <phrase role="special">{</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">preorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">class</phrase> <phrase role="identifier">iterator</phrase> <phrase role="special">:</phrase>
    <phrase role="keyword">public</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase> <phrase role="comment">/* see Note A */</phrase><phrase role="special">,</phrase>
                    <phrase role="keyword">typename</phrase> <phrase role="identifier">iterator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">value_type</phrase><phrase role="special">,</phrase>
                    <phrase role="keyword">typename</phrase> <phrase role="identifier">iterator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">difference_type</phrase><phrase role="special">,</phrase>
                    <phrase role="keyword">typename</phrase> <phrase role="identifier">iterator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">pointer</phrase><phrase role="special">,</phrase>
                    <phrase role="keyword">typename</phrase> <phrase role="identifier">iterator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">reference</phrase><phrase role="special">&gt;</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
    <phrase role="identifier">Cursor</phrase> <phrase role="identifier">current</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">Cursor</phrase> <phrase role="identifier">cursor_type</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">();</phrase>
    <phrase role="keyword">explicit</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">(</phrase><phrase role="identifier">Cursor</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>

    <phrase role="identifier">Cursor</phrase> <phrase role="identifier">base</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>         <phrase role="comment">// explicit</phrase>
    <phrase role="identifier">Reference</phrase> <phrase role="keyword">operator</phrase><phrase role="special">*()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">Pointer</phrase>   <phrase role="keyword">operator</phrase><phrase role="special">-&gt;()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

    <phrase role="identifier">iterator</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">++();</phrase>
    <phrase role="identifier">iterator</phrase>  <phrase role="keyword">operator</phrase><phrase role="special">++(</phrase><phrase role="keyword">int</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">--();</phrase>
    <phrase role="identifier">iterator</phrase>  <phrase role="keyword">operator</phrase><phrase role="special">--(</phrase><phrase role="keyword">int</phrase><phrase role="special">);</phrase>
  <phrase role="special">};</phrase>

<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace preorder</phrase>

<phrase role="special">}</phrase> <phrase role="comment">// namespace std</phrase>
</programlisting>
    <para>
      <emphasis>Note A:</emphasis> If <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typename</phrase>
      <phrase role="identifier">iterator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">iterator_category</phrase></computeroutput> is equivalent to <literal moreinfo="none">random_access_iterator_tag</literal>,
      put in <literal moreinfo="none">bidirectional_iterator_tag</literal>; otherwise put in <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">typename</phrase> <phrase role="identifier">iterator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">iterator_category</phrase></computeroutput>.
    </para>
    </simplesect>
  </section>
  <section id="tree.order_iter_requirements">
    <title><link linkend="tree.order_iter_requirements">Linear order <literal moreinfo="none">iterator</literal>
    requirements <phrase role="std_section_label">[order.iter.requirements]</phrase></link></title>
    <para>
      The template parameter <literal moreinfo="none">Cursor</literal> shall meet all the requirements
      of an Ascending Forward Cursor ([ascending.forward.cursors]). Additionally,
      for the template class and operators in <literal moreinfo="none">namespace</literal> <literal moreinfo="none">inorder</literal>,
      the template parameter <literal moreinfo="none">Cursor</literal> must be a Multiway Cursor
      ([cursor.flavors]).
    </para>
    <para>
      Additionally, <literal moreinfo="none">Cursor</literal> shall meet the requirements of a Ascending
      Bidirectional Cursor ([ascending.bidirectional.cursors]) if the member <literal moreinfo="none">operator--</literal>
      ([order.iter.op.eq]) is referenced in a way that requires instantiation (14.7.1).
    </para>
  </section>
  <section id="tree.order_iter_ops">
    <title><link linkend="tree.order_iter_ops"><literal moreinfo="none">inorder::iterator</literal>
    operations <phrase role="std_section_label">[order.iter.ops]</phrase></link></title>
    <section id="tree.order_iter_ops.order_iter_cons">
      <title><link linkend="tree.order_iter_ops.order_iter_cons"><literal moreinfo="none">inorder::iterator</literal>
      constructor <phrase role="std_section_label">[order.iter.cons]</phrase></link></title>
      <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">explicit</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">(</phrase><phrase role="identifier">Cursor</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Effects:</emphasis> Initializes <literal moreinfo="none">current</literal> with
        <literal moreinfo="none">x</literal>.
      </para>
      </simplesect>
    </section>
    <section id="tree.order_iter_ops.order_iter_conv">
      <title><link linkend="tree.order_iter_ops.order_iter_conv">Conversion <phrase role="std_section_label">[order.iter.conv]</phrase></link></title> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">Iterator</phrase> <phrase role="identifier">base</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase> <phrase role="comment">// explicit</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">current</phrase></computeroutput>
      </para>
      </simplesect>
    </section>
    <section id="tree.order_iter_ops.order_iter_op_star">
      <title><link linkend="tree.order_iter_ops.order_iter_op_star"><literal moreinfo="none">operator*</literal>
      <phrase role="std_section_label">[order.iter.op.star]</phrase></link></title>
      <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">Reference</phrase> <phrase role="keyword">operator</phrase><phrase role="special">*()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*</phrase><phrase role="identifier">current</phrase></computeroutput>
      </para>
      </simplesect>
    </section>
    <section id="tree.order_iter_ops.order_iter_op_ref">
      <title><link linkend="tree.order_iter_ops.order_iter_op_ref"><literal moreinfo="none">operator-&gt;</literal>
      <phrase role="std_section_label">[order.iter.op.ref]</phrase></link></title>
      <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">Pointer</phrase> <phrase role="keyword">operator</phrase><phrase role="special">-&gt;()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&amp;(</phrase><phrase role="keyword">operator</phrase><phrase role="special">*())</phrase></computeroutput>
      </para>
      </simplesect>
    </section>
    <section id="tree.order_iter_ops.order_iter_op_inc">
      <title><link linkend="tree.order_iter_ops.order_iter_op_inc"><literal moreinfo="none">operator++</literal>
      <phrase role="std_section_label">[order.iter.op.inc]</phrase></link></title>
      <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">iterator</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">++()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Effects:</emphasis> Sets <literal moreinfo="none">current</literal> to the next
        cursor in the given order.
      </para>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*</phrase><phrase role="keyword">this</phrase></computeroutput>
      </para>
      </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">iterator</phrase> <phrase role="keyword">operator</phrase><phrase role="special">++(</phrase><phrase role="keyword">int</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Effects:</emphasis>
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">iterator</phrase> <phrase role="identifier">tmp</phrase> <phrase role="special">=</phrase> <phrase role="special">*</phrase><phrase role="keyword">this</phrase><phrase role="special">;</phrase>
<phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="keyword">operator</phrase><phrase role="special">++();</phrase>
<phrase role="keyword">return</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
</programlisting>
      </simplesect>
    </section>
    <section id="tree.order_iter_ops.order_iter_op_dec">
      <title><link linkend="tree.order_iter_ops.order_iter_op_dec"><literal moreinfo="none">operator--</literal>
      <phrase role="std_section_label">[order.iter.op.dec]</phrase></link></title>
      <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">iterator</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">--()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Effects:</emphasis> Sets <literal moreinfo="none">current</literal> to the previous
        cursor in the given order.
      </para>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*</phrase><phrase role="keyword">this</phrase></computeroutput>
      </para>
      </simplesect> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">iterator</phrase> <phrase role="keyword">operator</phrase><phrase role="special">--(</phrase><phrase role="keyword">int</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Effects:</emphasis>
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">iterator</phrase> <phrase role="identifier">tmp</phrase> <phrase role="special">=</phrase> <phrase role="special">*</phrase><phrase role="keyword">this</phrase><phrase role="special">;</phrase>
<phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="keyword">operator</phrase><phrase role="special">--();</phrase>
<phrase role="keyword">return</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
</programlisting>
      </simplesect>
    </section>
    <section id="tree.order_iter_ops.order_iter_op_eq">
      <title><link linkend="tree.order_iter_ops.order_iter_op_eq"><literal moreinfo="none">operator==</literal>
      <phrase role="std_section_label">[order.iter.op.eq]</phrase></link></title>
      <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">==(</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">current</phrase> <phrase role="special">==</phrase> <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">current</phrase></computeroutput>
      </para>
      </simplesect>
    </section>
    <section id="tree.order_iter_ops.order_iter_op_ne">
      <title><link linkend="tree.order_iter_ops.order_iter_op_ne"><literal moreinfo="none">operator!=</literal>
      <phrase role="std_section_label">[order.iter.op.ne]</phrase></link></title>
      <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Cursor</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!=(</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase>
    <phrase role="keyword">const</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Cursor</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">);</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">current</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">current</phrase></computeroutput>
      </para>
      </simplesect>
    </section>
  </section>
  </section> </section> <section role="std_section" id="tree.proposal.algorithms" label="25" label-style="no-parent">
<title><link linkend="tree.proposal.algorithms">Algorithms
  library <phrase role="std_section_label">[algorithms]</phrase></link></title>
  <note>
    <para>
      Append to paragraph 2, <replaceable>Header <literal moreinfo="none">&lt;iterator&gt;</literal>
      synopsis</replaceable>, after <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="comment">// subclause 25.2,
      non-modifying sequence operations</phrase></computeroutput>.
    </para>
  </note>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="comment">// subclause 25.3, non-modifying hierarchy operations</phrase>
<phrase role="keyword">namespace</phrase> <phrase role="identifier">preorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">end</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cend</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace preorder</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">postorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">end</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cend</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace postorder</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">m</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">MultiwayHierarchy</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">m</phrase><phrase role="special">);</phrase>

  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">end</phrase><phrase role="special">(</phrase><phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">m</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cend</phrase><phrase role="special">(</phrase><phrase role="identifier">MultiwayHierarchy</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">m</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
  <note>
    <para>
      <literal moreinfo="none">[c]rbegin(...)</literal> and <literal moreinfo="none">[c]rend(..)</literal> are not
      provided as they can be achieved via <literal moreinfo="none">reverse_iterator({[c]begin(...)|[c]end(...)})</literal>
      (which also defines requirements when this is possible)
    </para>
  </note>
  <note>
    <para>
      Change paragraph 3 to read:
    </para>
  </note>
  <para>
    All of the algorithms are separated from the particular implementations of data
    structures and are parameterized by iterator or hierarchy types. Because of this,
    they can work with program-defined data structures, as long as these data structures
    have iterator or cursor types satisfying the assumptions on the algorithms.
  </para>
  <note>
    <para>
      Append to paragraph 5:
    </para>
  </note>
  <para>
    If an algorithm's template parameter is <literal moreinfo="none">Hierarchy</literal>, the actual
    template argument shall satisfy the requirements of a hierarchy ([hierarchy.req]).
    If an algorithm's template parameter is <literal moreinfo="none">MultiwayHierarchy</literal>,
    the actual template argument shall satisfy the requirements of a multiway hierarchy
    ([hierarchy.multiway]).
  </para>
  <note>
    <para>
      Insert after section 25.2 Non-modifying sequence operations [alg.nonmodifying]
    </para>
  </note>
  <section role="std_section" id="alg.hierarchy" label="3">
<title><link linkend="alg.hierarchy">Non-modifying hierarchy algorithms <phrase role="std_section_label">[alg.hierarchy]</phrase></link></title>

  <section id="tree.alg_hier_preorder">
    <title><link linkend="tree.alg_hier_preorder">Non-modifying hierarchy preorder
    range algorithms <phrase role="std_section_label">[alg.hier.preorder]</phrase></link></title>
    <section id="tree.alg_hier_preorder.alg_hier_pre_begin">
      <title><link linkend="tree.alg_hier_preorder.alg_hier_pre_begin">Preorder begin
      <phrase role="std_section_label">[alg.hier.pre.begin]</phrase></link></title>
      <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">preorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace preorder</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> An iterator pointing to the first element of
        <literal moreinfo="none">h</literal> in preorder.
      </para>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Complexity:</emphasis> constant
      </para>
      </simplesect>
    </section>
    <section id="tree.alg_hier_preorder.alg_hier_pre_end">
      <title><link linkend="tree.alg_hier_preorder.alg_hier_pre_end">Preorder end
      <phrase role="std_section_label">[alg.hier.pre.end]</phrase></link></title>
      <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">preorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">end</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cend</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace preorder</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> An iterator pointing one position past the
        last element of <literal moreinfo="none">h</literal> in preorder.
      </para>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Complexity:</emphasis> linear
      </para>
      </simplesect>
    </section>
  </section>
  <section id="tree.alg_hier_postorder">
    <title><link linkend="tree.alg_hier_postorder">Non-modifying hierarchy postorder
    range algorithms <phrase role="std_section_label">[alg.hier.postorder]</phrase></link></title>
    <section id="tree.alg_hier_postorder.alg_hier_post_begin">
      <title><link linkend="tree.alg_hier_postorder.alg_hier_post_begin">Postorder
      begin <phrase role="std_section_label">[alg.hier.post.begin]</phrase></link></title>
      <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">postorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace postorder</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> An iterator pointing to the first element of
        <literal moreinfo="none">h</literal> in postorder.
      </para>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Complexity:</emphasis> linear
      </para>
      </simplesect>
    </section>
    <section id="tree.alg_hier_postorder.alg_hier_post_end">
      <title><link linkend="tree.alg_hier_postorder.alg_hier_post_end">Postorder
      end <phrase role="std_section_label">[alg.hier.post.end]</phrase></link></title>
      <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">postorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">end</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Hierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cend</phrase><phrase role="special">(</phrase><phrase role="identifier">Hierarchy</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">h</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace postorder</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> An iterator pointing one position past the
        last element of <literal moreinfo="none">h</literal> in postorder.
      </para>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Complexity:</emphasis> constant
      </para>
      </simplesect>
    </section>
  </section>
  <section id="tree.alg_hier_inorder">
    <title><link linkend="tree.alg_hier_inorder">Non-modifying hierarchy inorder
    range algorithms <phrase role="std_section_label">[alg.hier.inorder]</phrase></link></title>
    <section id="tree.alg_hier_inorder.alg_hier_in_begin">
      <title><link linkend="tree.alg_hier_inorder.alg_hier_in_begin">Inorder begin
      <phrase role="std_section_label">[alg.hier.in.begin]</phrase></link></title>
      <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">m</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cbegin</phrase><phrase role="special">(</phrase><phrase role="identifier">MultiwayHierarchy</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">m</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> An iterator pointing to the first element of
        <literal moreinfo="none">h</literal> in inorder.
      </para>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Complexity:</emphasis> linear
      </para>
      </simplesect>
    </section>
    <section id="tree.alg_hier_inorder.alg_hier_in_end">
      <title><link linkend="tree.alg_hier_inorder.alg_hier_in_end">Inorder end <phrase role="std_section_label">[alg.hier.in.end]</phrase></link></title> <simplesect role="std_definition">
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">namespace</phrase> <phrase role="identifier">inorder</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">end</phrase><phrase role="special">(</phrase><phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">m</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">&gt;</phrase>
    <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">MultiwayHierarchy</phrase><phrase role="special">::</phrase><phrase role="identifier">const_cursor</phrase><phrase role="special">&gt;</phrase>
      <phrase role="identifier">cend</phrase><phrase role="special">(</phrase><phrase role="identifier">MultiwayHierarchy</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">m</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase> <phrase role="comment">// namespace inorder</phrase>
</programlisting>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Returns:</emphasis> An iterator pointing one position past the
        last element of <literal moreinfo="none">h</literal> in inorder.
      </para>
      </simplesect> <simplesect role="std_specification">
      <para>
        <emphasis>Complexity:</emphasis> linear
      </para>
      </simplesect>
    </section>
  </section>
  </section> </section> </section>

  <section id="tree.references">
    <title><link linkend="tree.references">References</link></title>
    <variablelist>
      <title>References</title>
      <varlistentry>
        <term>austern</term>
        <listitem>
          <para>
            Austern, Matthew H.; Stroustrup, Bjarne; Thorup, Mikkel; Wilikinson,
            John. <emphasis>Untangling the Balancing and Searching of Balanced Binary
            Search Trees</emphasis>, Software: Practice and Experience 33(13): 1273-1298
            (2003) Electronic Appendix: http://www.research.att.com/~bs/tree-appendix.pdf
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>cormen</term>
        <listitem>
          <para>
            Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford.
            <emphasis>Introduction to Algorithms</emphasis>. Second Edition (MIT
            Press, 2001)
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>dreizin</term>
        <listitem>
          <para>
            Dreizin, Vladimir; Kosnik, Benjamin; Tavory, Ami. <emphasis>Policy-Based
            Data Structures</emphasis>, http://gcc.gnu.org/onlinedocs/libstdc++<emphasis>ext/pb_ds</emphasis>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>ekman</term>
        <listitem>
          <para>
            Ekman, Rasmus. <emphasis>Structured Associative Containers</emphasis>,
            http://www.abc.se/~re/code/tst
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>gottschlich</term>
        <listitem>
          <para>
            Gottschlich, Justin. <emphasis>C++ Trees</emphasis>, http://www.gamedev.net/reference/articles/article2192.asp
            and http://www.gamedev.net/reference/articles/article2233.asp
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>haas</term>
        <listitem>
          <para>
            Haas, Mitchell. <emphasis>Tree Container Library</emphasis>, http://www.datasoftsolutions.net/tree_container_library/overview.php
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>karas</term>
        <listitem>
          <para>
            Karas, Walt. <emphasis>C++ AVL Tree Template</emphasis>, http://us.geocities.com/wkaras/gen_cpp/avl_tree.html
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>knuth97</term>
        <listitem>
          <para>
            Knuth, Donald E. <emphasis>The Art of Computer Programming</emphasis>.
            Volume 1: Fundamental Algorithms. Third Edition (Reading, Massachusetts:
            Addison-Wesley, 1997)
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>knuth98</term>
        <listitem>
          <para>
            Knuth, Donald E. <emphasis>The Art of Computer Programming</emphasis>.
            Volume 3: Sorting and Searching. Second Edition (Reading, Massachusetts:
            Addison-Wesley, 1998)
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>mirwaisi</term>
        <listitem>
          <para>
            Mirwaisi, Jeff. <emphasis>treelib</emphasis>, https://boost-consulting.com:8443/trac/soc/attachment/wiki/tree/resources/trees/treelib.tar.bz2
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>parent</term>
        <listitem>
          <para>
            Parent, Sean et al. <emphasis>forest</emphasis>, http://opensource.adobe.com/group__forest__related.html
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>peeters</term>
        <listitem>
          <para>
            Peeters, Kasper. <emphasis>tree.hh: an STL-like C++ tree class</emphasis>,
            http://www.aei.mpg.de/~peekas/tree/
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>rivera</term>
        <listitem>
          <para>
            Rivera, René. <emphasis>RankTree.h</emphasis>, http://redshift-software.com/~grafik/RankTree.h
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
</article>
